// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: io/openisms/api.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "io/openisms/Api.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Application);
GPBObjCClassDeclaration(Certification);
GPBObjCClassDeclaration(Company);
GPBObjCClassDeclaration(ConnectedAccount);
GPBObjCClassDeclaration(Date);
GPBObjCClassDeclaration(Employment);
GPBObjCClassDeclaration(GPBBoolValue);
GPBObjCClassDeclaration(GPBInt32Value);
GPBObjCClassDeclaration(GPBTimestamp);
GPBObjCClassDeclaration(Meta);
GPBObjCClassDeclaration(Name);
GPBObjCClassDeclaration(Network);
GPBObjCClassDeclaration(OperatingSystem);
GPBObjCClassDeclaration(Pentest);
GPBObjCClassDeclaration(Person);
GPBObjCClassDeclaration(Photo);
GPBObjCClassDeclaration(PhysicalObject);
GPBObjCClassDeclaration(Profile);
GPBObjCClassDeclaration(Repository);
GPBObjCClassDeclaration(SecurityFeatures);
GPBObjCClassDeclaration(SourceSystem);
GPBObjCClassDeclaration(Statistics);
GPBObjCClassDeclaration(User);

#pragma mark - ApiRoot

@implementation ApiRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ApiRoot_FileDescriptor

static GPBFileDescriptor *ApiRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"io.openisms.v1"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum Visibility

GPBEnumDescriptor *Visibility_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Undefined\000Public\000Internal\000Confidential\000";
    static const int32_t values[] = {
        Visibility_Undefined,
        Visibility_Public,
        Visibility_Internal,
        Visibility_Confidential,
    };
    static const char *extraTextFormatInfo = "\004\000)\000\001&\000\002(\000\003,\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Visibility)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Visibility_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Visibility_IsValidValue(int32_t value__) {
  switch (value__) {
    case Visibility_Undefined:
    case Visibility_Public:
    case Visibility_Internal:
    case Visibility_Confidential:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Event

@implementation Event

@dynamic hasMeta, meta;
@dynamic hasSource, source;
@dynamic usersArray, usersArray_Count;
@dynamic devicesArray, devicesArray_Count;
@dynamic repositoriesArray, repositoriesArray_Count;
@dynamic certificationArray, certificationArray_Count;
@dynamic pentestArray, pentestArray_Count;
@dynamic statsArray, statsArray_Count;

typedef struct Event__storage_ {
  uint32_t _has_storage_[1];
  Meta *meta;
  SourceSystem *source;
  NSMutableArray *usersArray;
  NSMutableArray *devicesArray;
  NSMutableArray *repositoriesArray;
  NSMutableArray *certificationArray;
  NSMutableArray *pentestArray;
  NSMutableArray *statsArray;
} Event__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "meta",
        .dataTypeSpecific.clazz = GPBObjCClass(Meta),
        .number = Event_FieldNumber_Meta,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Event__storage_, meta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "source",
        .dataTypeSpecific.clazz = GPBObjCClass(SourceSystem),
        .number = Event_FieldNumber_Source,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Event__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "usersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(User),
        .number = Event_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Event__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "devicesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(PhysicalObject),
        .number = Event_FieldNumber_DevicesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Event__storage_, devicesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "repositoriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Repository),
        .number = Event_FieldNumber_RepositoriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Event__storage_, repositoriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "certificationArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Certification),
        .number = Event_FieldNumber_CertificationArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Event__storage_, certificationArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pentestArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Pentest),
        .number = Event_FieldNumber_PentestArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Event__storage_, pentestArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "statsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Statistics),
        .number = Event_FieldNumber_StatsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Event__storage_, statsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Event class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Event__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Meta

@implementation Meta

@dynamic hasCreated, created;
@dynamic identifier;
@dynamic etag;

typedef struct Meta__storage_ {
  uint32_t _has_storage_[1];
  GPBTimestamp *created;
  NSString *identifier;
  NSString *etag;
} Meta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "created",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = Meta_FieldNumber_Created,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Meta__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = Nil,
        .number = Meta_FieldNumber_Identifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Meta__storage_, identifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "etag",
        .dataTypeSpecific.clazz = Nil,
        .number = Meta_FieldNumber_Etag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Meta__storage_, etag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Meta class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Meta__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SourceSystem

@implementation SourceSystem

@dynamic name;
@dynamic vendor;
@dynamic URL;
@dynamic logoURL;
@dynamic type;

typedef struct SourceSystem__storage_ {
  uint32_t _has_storage_[1];
  SourceSystem_SourceType type;
  NSString *name;
  NSString *vendor;
  NSString *URL;
  NSString *logoURL;
} SourceSystem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = SourceSystem_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SourceSystem__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vendor",
        .dataTypeSpecific.clazz = Nil,
        .number = SourceSystem_FieldNumber_Vendor,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SourceSystem__storage_, vendor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = SourceSystem_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SourceSystem__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "logoURL",
        .dataTypeSpecific.clazz = Nil,
        .number = SourceSystem_FieldNumber_LogoURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SourceSystem__storage_, logoURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = SourceSystem_SourceType_EnumDescriptor,
        .number = SourceSystem_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SourceSystem__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SourceSystem class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SourceSystem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003!!!\000\004\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SourceSystem_Type_RawValue(SourceSystem *message) {
  GPBDescriptor *descriptor = [SourceSystem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SourceSystem_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSourceSystem_Type_RawValue(SourceSystem *message, int32_t value) {
  GPBDescriptor *descriptor = [SourceSystem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SourceSystem_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum SourceSystem_SourceType

GPBEnumDescriptor *SourceSystem_SourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Undefined\000IdentityProvider\000SourceControl"
        "Management\000CloudProvider\000Database\000Networ"
        "k\000DeviceManagement\000SecuritySoftware\000Pass"
        "wordManager\000Communication\000HumanResources"
        "\000ContentManagementSystem\000Ticketing\000Custo"
        "merRelationshipManagement\000Finance\000Analyt"
        "ics\000";
    static const int32_t values[] = {
        SourceSystem_SourceType_Undefined,
        SourceSystem_SourceType_IdentityProvider,
        SourceSystem_SourceType_SourceControlManagement,
        SourceSystem_SourceType_CloudProvider,
        SourceSystem_SourceType_Database,
        SourceSystem_SourceType_Network,
        SourceSystem_SourceType_DeviceManagement,
        SourceSystem_SourceType_SecuritySoftware,
        SourceSystem_SourceType_PasswordManager,
        SourceSystem_SourceType_Communication,
        SourceSystem_SourceType_HumanResources,
        SourceSystem_SourceType_ContentManagementSystem,
        SourceSystem_SourceType_Ticketing,
        SourceSystem_SourceType_CustomerRelationshipManagement,
        SourceSystem_SourceType_Finance,
        SourceSystem_SourceType_Analytics,
    };
    static const char *extraTextFormatInfo = "\020\000)\000\001(\250\000\002&\247\252\000\003%\250\000\004(\000\005\'\000\006&\252\000\007(\250\000\010(\247\000\t-\000\n%\251\000\013\'\252\246\000\014)\000\r(\254\252\000\016\'\000\017)\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SourceSystem_SourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SourceSystem_SourceType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SourceSystem_SourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SourceSystem_SourceType_Undefined:
    case SourceSystem_SourceType_IdentityProvider:
    case SourceSystem_SourceType_SourceControlManagement:
    case SourceSystem_SourceType_CloudProvider:
    case SourceSystem_SourceType_Database:
    case SourceSystem_SourceType_Network:
    case SourceSystem_SourceType_DeviceManagement:
    case SourceSystem_SourceType_SecuritySoftware:
    case SourceSystem_SourceType_PasswordManager:
    case SourceSystem_SourceType_Communication:
    case SourceSystem_SourceType_HumanResources:
    case SourceSystem_SourceType_ContentManagementSystem:
    case SourceSystem_SourceType_Ticketing:
    case SourceSystem_SourceType_CustomerRelationshipManagement:
    case SourceSystem_SourceType_Finance:
    case SourceSystem_SourceType_Analytics:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - User

@implementation User

@dynamic hasPerson, person;
@dynamic hasSecondFactorActive, secondFactorActive;
@dynamic hasSecondFactorEnforced, secondFactorEnforced;
@dynamic hasActive, active;
@dynamic hasSuspended, suspended;
@dynamic hasDisabled, disabled;
@dynamic hasDeleted, deleted;
@dynamic groupsArray, groupsArray_Count;
@dynamic privilegesArray, privilegesArray_Count;
@dynamic hasEmployment, employment;
@dynamic connectedAccountsArray, connectedAccountsArray_Count;
@dynamic possessionsArray, possessionsArray_Count;
@dynamic tagsArray, tagsArray_Count;

typedef struct User__storage_ {
  uint32_t _has_storage_[1];
  Person *person;
  GPBBoolValue *secondFactorActive;
  GPBBoolValue *secondFactorEnforced;
  GPBBoolValue *active;
  GPBBoolValue *suspended;
  GPBBoolValue *disabled;
  GPBBoolValue *deleted;
  NSMutableArray *groupsArray;
  NSMutableArray *privilegesArray;
  Employment *employment;
  NSMutableArray *connectedAccountsArray;
  NSMutableArray *possessionsArray;
  NSMutableArray *tagsArray;
} User__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "person",
        .dataTypeSpecific.clazz = GPBObjCClass(Person),
        .number = User_FieldNumber_Person,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(User__storage_, person),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "secondFactorActive",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = User_FieldNumber_SecondFactorActive,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(User__storage_, secondFactorActive),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "secondFactorEnforced",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = User_FieldNumber_SecondFactorEnforced,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(User__storage_, secondFactorEnforced),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "active",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = User_FieldNumber_Active,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(User__storage_, active),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "suspended",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = User_FieldNumber_Suspended,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(User__storage_, suspended),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "disabled",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = User_FieldNumber_Disabled,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(User__storage_, disabled),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deleted",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = User_FieldNumber_Deleted,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(User__storage_, deleted),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = User_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(User__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "privilegesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = User_FieldNumber_PrivilegesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(User__storage_, privilegesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "employment",
        .dataTypeSpecific.clazz = GPBObjCClass(Employment),
        .number = User_FieldNumber_Employment,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(User__storage_, employment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "connectedAccountsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ConnectedAccount),
        .number = User_FieldNumber_ConnectedAccountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(User__storage_, connectedAccountsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "possessionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(PhysicalObject),
        .number = User_FieldNumber_PossessionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(User__storage_, possessionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = User_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(User__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[User class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(User__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Person

@implementation Person

@dynamic id_p;
@dynamic hasName, name;
@dynamic primaryEmail;
@dynamic otherEmailsArray, otherEmailsArray_Count;
@dynamic hasPicture, picture;
@dynamic company;
@dynamic hasCreated, created;
@dynamic hasUpdated, updated;

typedef struct Person__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  Name *name;
  NSString *primaryEmail;
  NSMutableArray *otherEmailsArray;
  Photo *picture;
  NSString *company;
  GPBTimestamp *created;
  GPBTimestamp *updated;
} Person__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Person_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Person__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = GPBObjCClass(Name),
        .number = Person_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Person__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "primaryEmail",
        .dataTypeSpecific.clazz = Nil,
        .number = Person_FieldNumber_PrimaryEmail,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Person__storage_, primaryEmail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "otherEmailsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Person_FieldNumber_OtherEmailsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Person__storage_, otherEmailsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "picture",
        .dataTypeSpecific.clazz = GPBObjCClass(Photo),
        .number = Person_FieldNumber_Picture,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Person__storage_, picture),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "company",
        .dataTypeSpecific.clazz = Nil,
        .number = Person_FieldNumber_Company,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Person__storage_, company),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "created",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = Person_FieldNumber_Created,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Person__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updated",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = Person_FieldNumber_Updated,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Person__storage_, updated),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Person class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Person__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Name

@implementation Name

@dynamic givenName;
@dynamic familyName;
@dynamic fullName;
@dynamic title;
@dynamic position;
@dynamic role;

typedef struct Name__storage_ {
  uint32_t _has_storage_[1];
  NSString *givenName;
  NSString *familyName;
  NSString *fullName;
  NSString *title;
  NSString *position;
  NSString *role;
} Name__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "givenName",
        .dataTypeSpecific.clazz = Nil,
        .number = Name_FieldNumber_GivenName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Name__storage_, givenName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "familyName",
        .dataTypeSpecific.clazz = Nil,
        .number = Name_FieldNumber_FamilyName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Name__storage_, familyName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fullName",
        .dataTypeSpecific.clazz = Nil,
        .number = Name_FieldNumber_FullName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Name__storage_, fullName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = Name_FieldNumber_Title,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Name__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "position",
        .dataTypeSpecific.clazz = Nil,
        .number = Name_FieldNumber_Position,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Name__storage_, position),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "role",
        .dataTypeSpecific.clazz = Nil,
        .number = Name_FieldNumber_Role,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Name__storage_, role),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Name class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Name__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Photo

@implementation Photo

@dynamic URL;
@dynamic base64Encoded;
@dynamic mimeType;
@dynamic etag;
@dynamic hasLastModified, lastModified;

typedef struct Photo__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *base64Encoded;
  NSString *mimeType;
  NSString *etag;
  GPBTimestamp *lastModified;
} Photo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = Photo_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Photo__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "base64Encoded",
        .dataTypeSpecific.clazz = Nil,
        .number = Photo_FieldNumber_Base64Encoded,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Photo__storage_, base64Encoded),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mimeType",
        .dataTypeSpecific.clazz = Nil,
        .number = Photo_FieldNumber_MimeType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Photo__storage_, mimeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "etag",
        .dataTypeSpecific.clazz = Nil,
        .number = Photo_FieldNumber_Etag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Photo__storage_, etag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastModified",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = Photo_FieldNumber_LastModified,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Photo__storage_, lastModified),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Photo class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Photo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001!!!\000\002\004\202\247\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Employment

@implementation Employment

@dynamic contract;
@dynamic status;
@dynamic hasBegin, begin;
@dynamic hasEnd, end;

typedef struct Employment__storage_ {
  uint32_t _has_storage_[1];
  NSString *contract;
  NSString *status;
  Date *begin;
  Date *end;
} Employment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contract",
        .dataTypeSpecific.clazz = Nil,
        .number = Employment_FieldNumber_Contract,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Employment__storage_, contract),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = Nil,
        .number = Employment_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Employment__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "begin",
        .dataTypeSpecific.clazz = GPBObjCClass(Date),
        .number = Employment_FieldNumber_Begin,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Employment__storage_, begin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.clazz = GPBObjCClass(Date),
        .number = Employment_FieldNumber_End,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Employment__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Employment class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Employment__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConnectedAccount

@implementation ConnectedAccount

@dynamic appId;
@dynamic appName;
@dynamic appType;
@dynamic appURL;
@dynamic userId;
@dynamic scopesArray, scopesArray_Count;

typedef struct ConnectedAccount__storage_ {
  uint32_t _has_storage_[1];
  NSString *appId;
  NSString *appName;
  NSString *appType;
  NSString *appURL;
  NSString *userId;
  NSMutableArray *scopesArray;
} ConnectedAccount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appId",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectedAccount_FieldNumber_AppId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConnectedAccount__storage_, appId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appName",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectedAccount_FieldNumber_AppName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConnectedAccount__storage_, appName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appType",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectedAccount_FieldNumber_AppType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ConnectedAccount__storage_, appType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appURL",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectedAccount_FieldNumber_AppURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ConnectedAccount__storage_, appURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectedAccount_FieldNumber_UserId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ConnectedAccount__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scopesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectedAccount_FieldNumber_ScopesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConnectedAccount__storage_, scopesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConnectedAccount class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConnectedAccount__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\003\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PhysicalObject

@implementation PhysicalObject

@dynamic type;
@dynamic name;
@dynamic manufacturer;
@dynamic vendor;
@dynamic identifier;
@dynamic serialNumber;
@dynamic imei;
@dynamic meid;
@dynamic networksArray, networksArray_Count;
@dynamic hostname;
@dynamic userAccountsArray, userAccountsArray_Count;
@dynamic hasOs, os;
@dynamic hasSecurity, security;
@dynamic profilesArray, profilesArray_Count;
@dynamic appsArray, appsArray_Count;
@dynamic tagsArray, tagsArray_Count;

typedef struct PhysicalObject__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  NSString *name;
  NSString *manufacturer;
  NSString *vendor;
  NSString *identifier;
  NSString *serialNumber;
  NSString *imei;
  NSString *meid;
  NSMutableArray *networksArray;
  NSString *hostname;
  NSMutableArray *userAccountsArray;
  OperatingSystem *os;
  SecurityFeatures *security;
  NSMutableArray *profilesArray;
  NSMutableArray *appsArray;
  NSMutableArray *tagsArray;
} PhysicalObject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = PhysicalObject_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = PhysicalObject_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "manufacturer",
        .dataTypeSpecific.clazz = Nil,
        .number = PhysicalObject_FieldNumber_Manufacturer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, manufacturer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vendor",
        .dataTypeSpecific.clazz = Nil,
        .number = PhysicalObject_FieldNumber_Vendor,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, vendor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = Nil,
        .number = PhysicalObject_FieldNumber_Identifier,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, identifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serialNumber",
        .dataTypeSpecific.clazz = Nil,
        .number = PhysicalObject_FieldNumber_SerialNumber,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, serialNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imei",
        .dataTypeSpecific.clazz = Nil,
        .number = PhysicalObject_FieldNumber_Imei,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, imei),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meid",
        .dataTypeSpecific.clazz = Nil,
        .number = PhysicalObject_FieldNumber_Meid,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, meid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "networksArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Network),
        .number = PhysicalObject_FieldNumber_NetworksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, networksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hostname",
        .dataTypeSpecific.clazz = Nil,
        .number = PhysicalObject_FieldNumber_Hostname,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, hostname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userAccountsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = PhysicalObject_FieldNumber_UserAccountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, userAccountsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "os",
        .dataTypeSpecific.clazz = GPBObjCClass(OperatingSystem),
        .number = PhysicalObject_FieldNumber_Os,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, os),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "security",
        .dataTypeSpecific.clazz = GPBObjCClass(SecurityFeatures),
        .number = PhysicalObject_FieldNumber_Security,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, security),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "profilesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Profile),
        .number = PhysicalObject_FieldNumber_ProfilesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, profilesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Application),
        .number = PhysicalObject_FieldNumber_AppsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, appsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = PhysicalObject_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PhysicalObject__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PhysicalObject class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PhysicalObject__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SecurityFeatures

@implementation SecurityFeatures

@dynamic hasActivationLock, activationLock;
@dynamic hasSupervised, supervised;
@dynamic hasFileVault, fileVault;
@dynamic hasFullDiskEncryption, fullDiskEncryption;
@dynamic hasSecurePassword, securePassword;
@dynamic hasAutomaticScreenLock, automaticScreenLock;
@dynamic hasScreenLockAfter, screenLockAfter;
@dynamic hasFirewallEnabled, firewallEnabled;
@dynamic hasAutomaticUpdates, automaticUpdates;

typedef struct SecurityFeatures__storage_ {
  uint32_t _has_storage_[1];
  GPBBoolValue *activationLock;
  GPBBoolValue *supervised;
  GPBBoolValue *fileVault;
  GPBBoolValue *fullDiskEncryption;
  GPBBoolValue *securePassword;
  GPBBoolValue *automaticScreenLock;
  GPBInt32Value *screenLockAfter;
  GPBBoolValue *firewallEnabled;
  GPBBoolValue *automaticUpdates;
} SecurityFeatures__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "activationLock",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = SecurityFeatures_FieldNumber_ActivationLock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SecurityFeatures__storage_, activationLock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "supervised",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = SecurityFeatures_FieldNumber_Supervised,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SecurityFeatures__storage_, supervised),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fileVault",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = SecurityFeatures_FieldNumber_FileVault,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SecurityFeatures__storage_, fileVault),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fullDiskEncryption",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = SecurityFeatures_FieldNumber_FullDiskEncryption,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SecurityFeatures__storage_, fullDiskEncryption),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "securePassword",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = SecurityFeatures_FieldNumber_SecurePassword,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SecurityFeatures__storage_, securePassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "automaticScreenLock",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = SecurityFeatures_FieldNumber_AutomaticScreenLock,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SecurityFeatures__storage_, automaticScreenLock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "screenLockAfter",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = SecurityFeatures_FieldNumber_ScreenLockAfter,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SecurityFeatures__storage_, screenLockAfter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "firewallEnabled",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = SecurityFeatures_FieldNumber_FirewallEnabled,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SecurityFeatures__storage_, firewallEnabled),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "automaticUpdates",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = SecurityFeatures_FieldNumber_AutomaticUpdates,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SecurityFeatures__storage_, automaticUpdates),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SecurityFeatures class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SecurityFeatures__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Network

@implementation Network

@dynamic name;
@dynamic type;
@dynamic macAddress;

typedef struct Network__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *type;
  NSString *macAddress;
} Network__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Network_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Network__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = Network_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Network__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "macAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = Network_FieldNumber_MacAddress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Network__storage_, macAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Network class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Network__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OperatingSystem

@implementation OperatingSystem

@dynamic os;
@dynamic majorVersion;
@dynamic fullVersion;

typedef struct OperatingSystem__storage_ {
  uint32_t _has_storage_[1];
  OperatingSystem_OperatingSystems os;
  NSString *majorVersion;
  NSString *fullVersion;
} OperatingSystem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "os",
        .dataTypeSpecific.enumDescFunc = OperatingSystem_OperatingSystems_EnumDescriptor,
        .number = OperatingSystem_FieldNumber_Os,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OperatingSystem__storage_, os),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "majorVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = OperatingSystem_FieldNumber_MajorVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OperatingSystem__storage_, majorVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fullVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = OperatingSystem_FieldNumber_FullVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OperatingSystem__storage_, fullVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OperatingSystem class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OperatingSystem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t OperatingSystem_Os_RawValue(OperatingSystem *message) {
  GPBDescriptor *descriptor = [OperatingSystem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OperatingSystem_FieldNumber_Os];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOperatingSystem_Os_RawValue(OperatingSystem *message, int32_t value) {
  GPBDescriptor *descriptor = [OperatingSystem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OperatingSystem_FieldNumber_Os];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum OperatingSystem_OperatingSystems

GPBEnumDescriptor *OperatingSystem_OperatingSystems_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Undefined\000Macos\000Windows\000Linux\000Unix\000Chrom"
        "eOs\000Ios\000Android\000Ros\000Other\000";
    static const int32_t values[] = {
        OperatingSystem_OperatingSystems_Undefined,
        OperatingSystem_OperatingSystems_Macos,
        OperatingSystem_OperatingSystems_Windows,
        OperatingSystem_OperatingSystems_Linux,
        OperatingSystem_OperatingSystems_Unix,
        OperatingSystem_OperatingSystems_ChromeOs,
        OperatingSystem_OperatingSystems_Ios,
        OperatingSystem_OperatingSystems_Android,
        OperatingSystem_OperatingSystems_Ros,
        OperatingSystem_OperatingSystems_Other,
    };
    static const char *extraTextFormatInfo = "\n\000)\000\001%\000\002\'\000\003%\000\004$\000\005&\242\000\006#\000\007\'\000\010#\000\t%\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OperatingSystem_OperatingSystems)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OperatingSystem_OperatingSystems_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OperatingSystem_OperatingSystems_IsValidValue(int32_t value__) {
  switch (value__) {
    case OperatingSystem_OperatingSystems_Undefined:
    case OperatingSystem_OperatingSystems_Macos:
    case OperatingSystem_OperatingSystems_Windows:
    case OperatingSystem_OperatingSystems_Linux:
    case OperatingSystem_OperatingSystems_Unix:
    case OperatingSystem_OperatingSystems_ChromeOs:
    case OperatingSystem_OperatingSystems_Ios:
    case OperatingSystem_OperatingSystems_Android:
    case OperatingSystem_OperatingSystems_Ros:
    case OperatingSystem_OperatingSystems_Other:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Application

@implementation Application

@dynamic name;
@dynamic path;
@dynamic vendor;
@dynamic URL;
@dynamic description_p;
@dynamic version;
@dynamic hasSigned_p, signed_p;
@dynamic hasSystemApp, systemApp;
@dynamic installationSource;

typedef struct Application__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *path;
  NSString *vendor;
  NSString *URL;
  NSString *description_p;
  NSString *version;
  GPBBoolValue *signed_p;
  GPBBoolValue *systemApp;
  NSString *installationSource;
} Application__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Application_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Application__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "path",
        .dataTypeSpecific.clazz = Nil,
        .number = Application_FieldNumber_Path,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Application__storage_, path),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vendor",
        .dataTypeSpecific.clazz = Nil,
        .number = Application_FieldNumber_Vendor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Application__storage_, vendor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = Application_FieldNumber_URL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Application__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Application_FieldNumber_Description_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Application__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = Application_FieldNumber_Version,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Application__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signed_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = Application_FieldNumber_Signed_p,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Application__storage_, signed_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "systemApp",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = Application_FieldNumber_SystemApp,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Application__storage_, systemApp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "installationSource",
        .dataTypeSpecific.clazz = Nil,
        .number = Application_FieldNumber_InstallationSource,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Application__storage_, installationSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Application class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Application__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Profile

@implementation Profile

@dynamic name;
@dynamic identifier;
@dynamic hasRemovalAllowed, removalAllowed;
@dynamic payloadType;
@dynamic payloadIdentifier;

typedef struct Profile__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *identifier;
  GPBBoolValue *removalAllowed;
  NSString *payloadType;
  NSString *payloadIdentifier;
} Profile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Profile_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Profile__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = Nil,
        .number = Profile_FieldNumber_Identifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Profile__storage_, identifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "removalAllowed",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = Profile_FieldNumber_RemovalAllowed,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Profile__storage_, removalAllowed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "payloadType",
        .dataTypeSpecific.clazz = Nil,
        .number = Profile_FieldNumber_PayloadType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Profile__storage_, payloadType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payloadIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = Profile_FieldNumber_PayloadIdentifier,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Profile__storage_, payloadIdentifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Profile class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Profile__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Date

@implementation Date

@dynamic year;
@dynamic month;
@dynamic day;

typedef struct Date__storage_ {
  uint32_t _has_storage_[1];
  int32_t year;
  int32_t month;
  int32_t day;
} Date__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "year",
        .dataTypeSpecific.clazz = Nil,
        .number = Date_FieldNumber_Year,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Date__storage_, year),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "month",
        .dataTypeSpecific.clazz = Nil,
        .number = Date_FieldNumber_Month,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Date__storage_, month),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "day",
        .dataTypeSpecific.clazz = Nil,
        .number = Date_FieldNumber_Day,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Date__storage_, day),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Date class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Date__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Certification

@implementation Certification

@dynamic type;
@dynamic URL;
@dynamic tagsArray, tagsArray_Count;

typedef struct Certification__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  NSString *URL;
  NSMutableArray *tagsArray;
} Certification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = Certification_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Certification__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = Certification_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Certification__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Certification_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Certification__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Certification class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Certification__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Company

@implementation Company

@dynamic name;
@dynamic URL;
@dynamic category;
@dynamic hasContact, contact;
@dynamic addressArray, addressArray_Count;

typedef struct Company__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *URL;
  NSString *category;
  Person *contact;
  NSMutableArray *addressArray;
} Company__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Company_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Company__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = Company_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Company__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.clazz = Nil,
        .number = Company_FieldNumber_Category,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Company__storage_, category),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contact",
        .dataTypeSpecific.clazz = GPBObjCClass(Person),
        .number = Company_FieldNumber_Contact,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Company__storage_, contact),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addressArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Company_FieldNumber_AddressArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Company__storage_, addressArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Company class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Company__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Pentest

@implementation Pentest

@dynamic id_p;
@dynamic hasBegin, begin;
@dynamic hasEnd, end;
@dynamic hasCompany, company;
@dynamic focus;
@dynamic passed;
@dynamic result;
@dynamic URL;
@dynamic contactsArray, contactsArray_Count;
@dynamic tagsArray, tagsArray_Count;

typedef struct Pentest__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  Date *begin;
  Date *end;
  Company *company;
  NSString *focus;
  NSString *result;
  NSString *URL;
  NSMutableArray *contactsArray;
  NSMutableArray *tagsArray;
} Pentest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Pentest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Pentest__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "begin",
        .dataTypeSpecific.clazz = GPBObjCClass(Date),
        .number = Pentest_FieldNumber_Begin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Pentest__storage_, begin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.clazz = GPBObjCClass(Date),
        .number = Pentest_FieldNumber_End,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Pentest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "company",
        .dataTypeSpecific.clazz = GPBObjCClass(Company),
        .number = Pentest_FieldNumber_Company,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Pentest__storage_, company),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "focus",
        .dataTypeSpecific.clazz = Nil,
        .number = Pentest_FieldNumber_Focus,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Pentest__storage_, focus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "passed",
        .dataTypeSpecific.clazz = Nil,
        .number = Pentest_FieldNumber_Passed,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "result",
        .dataTypeSpecific.clazz = Nil,
        .number = Pentest_FieldNumber_Result,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Pentest__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = Pentest_FieldNumber_URL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Pentest__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contactsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Person),
        .number = Pentest_FieldNumber_ContactsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Pentest__storage_, contactsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Pentest_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Pentest__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Pentest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Pentest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\010!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Repository

@implementation Repository

@dynamic name;
@dynamic URL;
@dynamic description_p;
@dynamic visibility;
@dynamic membersArray, membersArray_Count;
@dynamic securityAttributesArray, securityAttributesArray_Count;
@dynamic tagsArray, tagsArray_Count;

typedef struct Repository__storage_ {
  uint32_t _has_storage_[1];
  Visibility visibility;
  NSString *name;
  NSString *URL;
  NSString *description_p;
  NSMutableArray *membersArray;
  NSMutableArray *securityAttributesArray;
  NSMutableArray *tagsArray;
} Repository__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Repository_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Repository__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = Repository_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Repository__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Repository_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Repository__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "visibility",
        .dataTypeSpecific.enumDescFunc = Visibility_EnumDescriptor,
        .number = Repository_FieldNumber_Visibility,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Repository__storage_, visibility),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "membersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Person),
        .number = Repository_FieldNumber_MembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Repository__storage_, membersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "securityAttributesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Repository_FieldNumber_SecurityAttributesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Repository__storage_, securityAttributesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Repository_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Repository__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Repository class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Repository__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Repository_Visibility_RawValue(Repository *message) {
  GPBDescriptor *descriptor = [Repository descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Repository_FieldNumber_Visibility];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRepository_Visibility_RawValue(Repository *message, int32_t value) {
  GPBDescriptor *descriptor = [Repository descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Repository_FieldNumber_Visibility];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Statistics

@implementation Statistics

@dynamic identifier;
@dynamic name;
@dynamic value;
@dynamic comment;

typedef struct Statistics__storage_ {
  uint32_t _has_storage_[1];
  int32_t value;
  NSString *identifier;
  NSString *name;
  NSString *comment;
} Statistics__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = Nil,
        .number = Statistics_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Statistics__storage_, identifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Statistics_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Statistics__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = Statistics_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Statistics__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "comment",
        .dataTypeSpecific.clazz = Nil,
        .number = Statistics_FieldNumber_Comment,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Statistics__storage_, comment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Statistics class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Statistics__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
