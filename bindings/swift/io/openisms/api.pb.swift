// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: io/openisms/api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Io_Openisms_V1_Visibility: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case undefined // = 0
  case `public` // = 1

  /// private
  case `internal` // = 2
  case confidential // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .public
    case 2: self = .internal
    case 3: self = .confidential
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .public: return 1
    case .internal: return 2
    case .confidential: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Io_Openisms_V1_Visibility: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Openisms_V1_Visibility] = [
    .undefined,
    .public,
    .internal,
    .confidential,
  ]
}

#endif  // swift(>=4.2)

struct Io_Openisms_V1_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var meta: Io_Openisms_V1_Meta {
    get {return _meta ?? Io_Openisms_V1_Meta()}
    set {_meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  var hasMeta: Bool {return self._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  mutating func clearMeta() {self._meta = nil}

  var source: Io_Openisms_V1_SourceSystem {
    get {return _source ?? Io_Openisms_V1_SourceSystem()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var users: [Io_Openisms_V1_User] = []

  var devices: [Io_Openisms_V1_PhysicalObject] = []

  var repositories: [Io_Openisms_V1_Repository] = []

  var certification: [Io_Openisms_V1_Certification] = []

  var pentest: [Io_Openisms_V1_Pentest] = []

  var stats: [Io_Openisms_V1_Statistics] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _meta: Io_Openisms_V1_Meta? = nil
  fileprivate var _source: Io_Openisms_V1_SourceSystem? = nil
}

struct Io_Openisms_V1_Meta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return self._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {self._created = nil}

  var identifier: String = String()

  var etag: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Io_Openisms_V1_SourceSystem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var vendor: String = String()

  var url: String = String()

  var logoURL: String = String()

  var type: Io_Openisms_V1_SourceSystem.SourceType = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SourceType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case undefined // = 0

    /// Infrastructure
    case identityProvider // = 1
    case sourceControlManagement // = 2

    /// AWS, Google Cloud, Azure, Hetzner, OVH
    case cloudProvider // = 3
    case database // = 4

    /// Tailscale, Wireguard, VPN, Cloudflare
    case network // = 5

    /// Devices & Security, connected to laptops
    case deviceManagement // = 10

    /// Anti-virus
    case securitySoftware // = 11

    /// MFA, 1Password
    case passwordManager // = 12

    /// Tools & SaaS
    case communication // = 20

    /// HR, Personio, BambooHR
    case humanResources // = 21

    /// CMS, Notion, Confluence, WordPress
    case contentManagementSystem // = 22

    /// Jira, Trello, Asana, Monday.com, airfocus
    case ticketing // = 23

    /// CRM
    case customerRelationshipManagement // = 24

    /// Stripe, invoice handling
    case finance // = 25
    case analytics // = 26
    case UNRECOGNIZED(Int)

    init() {
      self = .undefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .identityProvider
      case 2: self = .sourceControlManagement
      case 3: self = .cloudProvider
      case 4: self = .database
      case 5: self = .network
      case 10: self = .deviceManagement
      case 11: self = .securitySoftware
      case 12: self = .passwordManager
      case 20: self = .communication
      case 21: self = .humanResources
      case 22: self = .contentManagementSystem
      case 23: self = .ticketing
      case 24: self = .customerRelationshipManagement
      case 25: self = .finance
      case 26: self = .analytics
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .identityProvider: return 1
      case .sourceControlManagement: return 2
      case .cloudProvider: return 3
      case .database: return 4
      case .network: return 5
      case .deviceManagement: return 10
      case .securitySoftware: return 11
      case .passwordManager: return 12
      case .communication: return 20
      case .humanResources: return 21
      case .contentManagementSystem: return 22
      case .ticketing: return 23
      case .customerRelationshipManagement: return 24
      case .finance: return 25
      case .analytics: return 26
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Io_Openisms_V1_SourceSystem.SourceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Openisms_V1_SourceSystem.SourceType] = [
    .undefined,
    .identityProvider,
    .sourceControlManagement,
    .cloudProvider,
    .database,
    .network,
    .deviceManagement,
    .securitySoftware,
    .passwordManager,
    .communication,
    .humanResources,
    .contentManagementSystem,
    .ticketing,
    .customerRelationshipManagement,
    .finance,
    .analytics,
  ]
}

#endif  // swift(>=4.2)

struct Io_Openisms_V1_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var person: Io_Openisms_V1_Person {
    get {return _storage._person ?? Io_Openisms_V1_Person()}
    set {_uniqueStorage()._person = newValue}
  }
  /// Returns true if `person` has been explicitly set.
  var hasPerson: Bool {return _storage._person != nil}
  /// Clears the value of `person`. Subsequent reads from it will return its default value.
  mutating func clearPerson() {_uniqueStorage()._person = nil}

  var secondFactorActive: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._secondFactorActive ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._secondFactorActive = newValue}
  }
  /// Returns true if `secondFactorActive` has been explicitly set.
  var hasSecondFactorActive: Bool {return _storage._secondFactorActive != nil}
  /// Clears the value of `secondFactorActive`. Subsequent reads from it will return its default value.
  mutating func clearSecondFactorActive() {_uniqueStorage()._secondFactorActive = nil}

  var secondFactorEnforced: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._secondFactorEnforced ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._secondFactorEnforced = newValue}
  }
  /// Returns true if `secondFactorEnforced` has been explicitly set.
  var hasSecondFactorEnforced: Bool {return _storage._secondFactorEnforced != nil}
  /// Clears the value of `secondFactorEnforced`. Subsequent reads from it will return its default value.
  mutating func clearSecondFactorEnforced() {_uniqueStorage()._secondFactorEnforced = nil}

  var active: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._active ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._active = newValue}
  }
  /// Returns true if `active` has been explicitly set.
  var hasActive: Bool {return _storage._active != nil}
  /// Clears the value of `active`. Subsequent reads from it will return its default value.
  mutating func clearActive() {_uniqueStorage()._active = nil}

  var suspended: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._suspended ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._suspended = newValue}
  }
  /// Returns true if `suspended` has been explicitly set.
  var hasSuspended: Bool {return _storage._suspended != nil}
  /// Clears the value of `suspended`. Subsequent reads from it will return its default value.
  mutating func clearSuspended() {_uniqueStorage()._suspended = nil}

  var disabled: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._disabled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._disabled = newValue}
  }
  /// Returns true if `disabled` has been explicitly set.
  var hasDisabled: Bool {return _storage._disabled != nil}
  /// Clears the value of `disabled`. Subsequent reads from it will return its default value.
  mutating func clearDisabled() {_uniqueStorage()._disabled = nil}

  var deleted: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._deleted ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._deleted = newValue}
  }
  /// Returns true if `deleted` has been explicitly set.
  var hasDeleted: Bool {return _storage._deleted != nil}
  /// Clears the value of `deleted`. Subsequent reads from it will return its default value.
  mutating func clearDeleted() {_uniqueStorage()._deleted = nil}

  var groups: [String] {
    get {return _storage._groups}
    set {_uniqueStorage()._groups = newValue}
  }

  var privileges: [String] {
    get {return _storage._privileges}
    set {_uniqueStorage()._privileges = newValue}
  }

  var employment: Io_Openisms_V1_Employment {
    get {return _storage._employment ?? Io_Openisms_V1_Employment()}
    set {_uniqueStorage()._employment = newValue}
  }
  /// Returns true if `employment` has been explicitly set.
  var hasEmployment: Bool {return _storage._employment != nil}
  /// Clears the value of `employment`. Subsequent reads from it will return its default value.
  mutating func clearEmployment() {_uniqueStorage()._employment = nil}

  /// via SSO, SAML, OIDC
  var connectedAccounts: [Io_Openisms_V1_ConnectedAccount] {
    get {return _storage._connectedAccounts}
    set {_uniqueStorage()._connectedAccounts = newValue}
  }

  /// Laptop, Phone, Adaptor
  var possessions: [Io_Openisms_V1_PhysicalObject] {
    get {return _storage._possessions}
    set {_uniqueStorage()._possessions = newValue}
  }

  var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Openisms_V1_Person {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var name: Io_Openisms_V1_Name {
    get {return _storage._name ?? Io_Openisms_V1_Name()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  var primaryEmail: String {
    get {return _storage._primaryEmail}
    set {_uniqueStorage()._primaryEmail = newValue}
  }

  var otherEmails: [String] {
    get {return _storage._otherEmails}
    set {_uniqueStorage()._otherEmails = newValue}
  }

  var picture: Io_Openisms_V1_UrlWithEtag {
    get {return _storage._picture ?? Io_Openisms_V1_UrlWithEtag()}
    set {_uniqueStorage()._picture = newValue}
  }
  /// Returns true if `picture` has been explicitly set.
  var hasPicture: Bool {return _storage._picture != nil}
  /// Clears the value of `picture`. Subsequent reads from it will return its default value.
  mutating func clearPicture() {_uniqueStorage()._picture = nil}

  var company: String {
    get {return _storage._company}
    set {_uniqueStorage()._company = newValue}
  }

  /// technical date
  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {_uniqueStorage()._created = nil}

  /// technical date
  var updated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updated = newValue}
  }
  /// Returns true if `updated` has been explicitly set.
  var hasUpdated: Bool {return _storage._updated != nil}
  /// Clears the value of `updated`. Subsequent reads from it will return its default value.
  mutating func clearUpdated() {_uniqueStorage()._updated = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Openisms_V1_Name {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var givenName: String = String()

  var familyName: String = String()

  var fullName: String = String()

  /// Dr., Sir
  var title: String = String()

  /// CEO, CTO
  var position: String = String()

  /// Developer, Customer Support Agent
  var role: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Openisms_V1_UrlWithEtag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  var etag: String = String()

  var lastModified: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastModified ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastModified = newValue}
  }
  /// Returns true if `lastModified` has been explicitly set.
  var hasLastModified: Bool {return self._lastModified != nil}
  /// Clears the value of `lastModified`. Subsequent reads from it will return its default value.
  mutating func clearLastModified() {self._lastModified = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastModified: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Io_Openisms_V1_Employment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// full-time, intern, consultant
  var contract: String = String()

  /// candidate, hired, active, hiatus, terminated, left
  var status: String = String()

  var begin: Io_Openisms_V1_Date {
    get {return _begin ?? Io_Openisms_V1_Date()}
    set {_begin = newValue}
  }
  /// Returns true if `begin` has been explicitly set.
  var hasBegin: Bool {return self._begin != nil}
  /// Clears the value of `begin`. Subsequent reads from it will return its default value.
  mutating func clearBegin() {self._begin = nil}

  var end: Io_Openisms_V1_Date {
    get {return _end ?? Io_Openisms_V1_Date()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  mutating func clearEnd() {self._end = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _begin: Io_Openisms_V1_Date? = nil
  fileprivate var _end: Io_Openisms_V1_Date? = nil
}

struct Io_Openisms_V1_ConnectedAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: String = String()

  var appName: String = String()

  var appType: String = String()

  var appURL: String = String()

  var userID: String = String()

  var scopes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Openisms_V1_PhysicalObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var manufacturer: String {
    get {return _storage._manufacturer}
    set {_uniqueStorage()._manufacturer = newValue}
  }

  var vendor: String {
    get {return _storage._vendor}
    set {_uniqueStorage()._vendor = newValue}
  }

  /// company-internal
  var identifier: String {
    get {return _storage._identifier}
    set {_uniqueStorage()._identifier = newValue}
  }

  var serialNumber: String {
    get {return _storage._serialNumber}
    set {_uniqueStorage()._serialNumber = newValue}
  }

  var imei: String {
    get {return _storage._imei}
    set {_uniqueStorage()._imei = newValue}
  }

  var meid: String {
    get {return _storage._meid}
    set {_uniqueStorage()._meid = newValue}
  }

  var networks: [Io_Openisms_V1_Network] {
    get {return _storage._networks}
    set {_uniqueStorage()._networks = newValue}
  }

  var hostname: String {
    get {return _storage._hostname}
    set {_uniqueStorage()._hostname = newValue}
  }

  var userAccounts: [String] {
    get {return _storage._userAccounts}
    set {_uniqueStorage()._userAccounts = newValue}
  }

  var os: Io_Openisms_V1_OperatingSystem {
    get {return _storage._os ?? Io_Openisms_V1_OperatingSystem()}
    set {_uniqueStorage()._os = newValue}
  }
  /// Returns true if `os` has been explicitly set.
  var hasOs: Bool {return _storage._os != nil}
  /// Clears the value of `os`. Subsequent reads from it will return its default value.
  mutating func clearOs() {_uniqueStorage()._os = nil}

  var security: Io_Openisms_V1_SecurityFeatures {
    get {return _storage._security ?? Io_Openisms_V1_SecurityFeatures()}
    set {_uniqueStorage()._security = newValue}
  }
  /// Returns true if `security` has been explicitly set.
  var hasSecurity: Bool {return _storage._security != nil}
  /// Clears the value of `security`. Subsequent reads from it will return its default value.
  mutating func clearSecurity() {_uniqueStorage()._security = nil}

  var profiles: [Io_Openisms_V1_Profile] {
    get {return _storage._profiles}
    set {_uniqueStorage()._profiles = newValue}
  }

  var apps: [Io_Openisms_V1_Application] {
    get {return _storage._apps}
    set {_uniqueStorage()._apps = newValue}
  }

  var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Openisms_V1_SecurityFeatures {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activationLock: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _activationLock ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_activationLock = newValue}
  }
  /// Returns true if `activationLock` has been explicitly set.
  var hasActivationLock: Bool {return self._activationLock != nil}
  /// Clears the value of `activationLock`. Subsequent reads from it will return its default value.
  mutating func clearActivationLock() {self._activationLock = nil}

  var supervised: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _supervised ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_supervised = newValue}
  }
  /// Returns true if `supervised` has been explicitly set.
  var hasSupervised: Bool {return self._supervised != nil}
  /// Clears the value of `supervised`. Subsequent reads from it will return its default value.
  mutating func clearSupervised() {self._supervised = nil}

  var fileVault: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _fileVault ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_fileVault = newValue}
  }
  /// Returns true if `fileVault` has been explicitly set.
  var hasFileVault: Bool {return self._fileVault != nil}
  /// Clears the value of `fileVault`. Subsequent reads from it will return its default value.
  mutating func clearFileVault() {self._fileVault = nil}

  var fullDiskEncryption: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _fullDiskEncryption ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_fullDiskEncryption = newValue}
  }
  /// Returns true if `fullDiskEncryption` has been explicitly set.
  var hasFullDiskEncryption: Bool {return self._fullDiskEncryption != nil}
  /// Clears the value of `fullDiskEncryption`. Subsequent reads from it will return its default value.
  mutating func clearFullDiskEncryption() {self._fullDiskEncryption = nil}

  var securePassword: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _securePassword ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_securePassword = newValue}
  }
  /// Returns true if `securePassword` has been explicitly set.
  var hasSecurePassword: Bool {return self._securePassword != nil}
  /// Clears the value of `securePassword`. Subsequent reads from it will return its default value.
  mutating func clearSecurePassword() {self._securePassword = nil}

  var automaticScreenLock: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _automaticScreenLock ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_automaticScreenLock = newValue}
  }
  /// Returns true if `automaticScreenLock` has been explicitly set.
  var hasAutomaticScreenLock: Bool {return self._automaticScreenLock != nil}
  /// Clears the value of `automaticScreenLock`. Subsequent reads from it will return its default value.
  mutating func clearAutomaticScreenLock() {self._automaticScreenLock = nil}

  var screenLockAfter: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _screenLockAfter ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_screenLockAfter = newValue}
  }
  /// Returns true if `screenLockAfter` has been explicitly set.
  var hasScreenLockAfter: Bool {return self._screenLockAfter != nil}
  /// Clears the value of `screenLockAfter`. Subsequent reads from it will return its default value.
  mutating func clearScreenLockAfter() {self._screenLockAfter = nil}

  var firewallEnabled: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _firewallEnabled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_firewallEnabled = newValue}
  }
  /// Returns true if `firewallEnabled` has been explicitly set.
  var hasFirewallEnabled: Bool {return self._firewallEnabled != nil}
  /// Clears the value of `firewallEnabled`. Subsequent reads from it will return its default value.
  mutating func clearFirewallEnabled() {self._firewallEnabled = nil}

  var automaticUpdates: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _automaticUpdates ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_automaticUpdates = newValue}
  }
  /// Returns true if `automaticUpdates` has been explicitly set.
  var hasAutomaticUpdates: Bool {return self._automaticUpdates != nil}
  /// Clears the value of `automaticUpdates`. Subsequent reads from it will return its default value.
  mutating func clearAutomaticUpdates() {self._automaticUpdates = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _activationLock: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _supervised: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _fileVault: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _fullDiskEncryption: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _securePassword: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _automaticScreenLock: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _screenLockAfter: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _firewallEnabled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _automaticUpdates: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

struct Io_Openisms_V1_Network {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  /// ethernet, bluetooth, virtual, gsm, vpc
  var type: String = String()

  var macAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Openisms_V1_OperatingSystem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var os: Io_Openisms_V1_OperatingSystem.OperatingSystems = .undefined

  var majorVersion: String = String()

  var fullVersion: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OperatingSystems: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case undefined // = 0
    case macos // = 1
    case windows // = 2
    case linux // = 3
    case unix // = 4
    case chromeOs // = 5
    case ios // = 10
    case android // = 11
    case ros // = 14
    case other // = 15
    case UNRECOGNIZED(Int)

    init() {
      self = .undefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .macos
      case 2: self = .windows
      case 3: self = .linux
      case 4: self = .unix
      case 5: self = .chromeOs
      case 10: self = .ios
      case 11: self = .android
      case 14: self = .ros
      case 15: self = .other
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .macos: return 1
      case .windows: return 2
      case .linux: return 3
      case .unix: return 4
      case .chromeOs: return 5
      case .ios: return 10
      case .android: return 11
      case .ros: return 14
      case .other: return 15
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Io_Openisms_V1_OperatingSystem.OperatingSystems: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Openisms_V1_OperatingSystem.OperatingSystems] = [
    .undefined,
    .macos,
    .windows,
    .linux,
    .unix,
    .chromeOs,
    .ios,
    .android,
    .ros,
    .other,
  ]
}

#endif  // swift(>=4.2)

struct Io_Openisms_V1_Application {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var path: String = String()

  var vendor: String = String()

  var url: String = String()

  var description_p: String = String()

  var version: String = String()

  var signed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _signed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_signed = newValue}
  }
  /// Returns true if `signed` has been explicitly set.
  var hasSigned: Bool {return self._signed != nil}
  /// Clears the value of `signed`. Subsequent reads from it will return its default value.
  mutating func clearSigned() {self._signed = nil}

  var systemApp: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _systemApp ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_systemApp = newValue}
  }
  /// Returns true if `systemApp` has been explicitly set.
  var hasSystemApp: Bool {return self._systemApp != nil}
  /// Clears the value of `systemApp`. Subsequent reads from it will return its default value.
  mutating func clearSystemApp() {self._systemApp = nil}

  /// App Store; homebrew; MDM
  var installationSource: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _systemApp: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

struct Io_Openisms_V1_Profile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var identifier: String = String()

  var removalAllowed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _removalAllowed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_removalAllowed = newValue}
  }
  /// Returns true if `removalAllowed` has been explicitly set.
  var hasRemovalAllowed: Bool {return self._removalAllowed != nil}
  /// Clears the value of `removalAllowed`. Subsequent reads from it will return its default value.
  mutating func clearRemovalAllowed() {self._removalAllowed = nil}

  var payloadType: String = String()

  var payloadIdentifier: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _removalAllowed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// from https://github.com/googleapis/googleapis/blob/master/google/type/date.proto
struct Io_Openisms_V1_Date {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
  var year: Int32 = 0

  /// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
  var month: Int32 = 0

  /// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a
  /// year by itself or a year and month where the day isn't significant.
  var day: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Openisms_V1_Certification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ISO27k, SOC2, HIPAA
  var type: String = String()

  /// to certificate
  var url: String = String()

  var tags: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Openisms_V1_Company {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var url: String = String()

  var category: String = String()

  var contact: Io_Openisms_V1_Person {
    get {return _contact ?? Io_Openisms_V1_Person()}
    set {_contact = newValue}
  }
  /// Returns true if `contact` has been explicitly set.
  var hasContact: Bool {return self._contact != nil}
  /// Clears the value of `contact`. Subsequent reads from it will return its default value.
  mutating func clearContact() {self._contact = nil}

  var address: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contact: Io_Openisms_V1_Person? = nil
}

struct Io_Openisms_V1_Pentest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var begin: Io_Openisms_V1_Date {
    get {return _storage._begin ?? Io_Openisms_V1_Date()}
    set {_uniqueStorage()._begin = newValue}
  }
  /// Returns true if `begin` has been explicitly set.
  var hasBegin: Bool {return _storage._begin != nil}
  /// Clears the value of `begin`. Subsequent reads from it will return its default value.
  mutating func clearBegin() {_uniqueStorage()._begin = nil}

  var end: Io_Openisms_V1_Date {
    get {return _storage._end ?? Io_Openisms_V1_Date()}
    set {_uniqueStorage()._end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  var hasEnd: Bool {return _storage._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  mutating func clearEnd() {_uniqueStorage()._end = nil}

  var company: Io_Openisms_V1_Company {
    get {return _storage._company ?? Io_Openisms_V1_Company()}
    set {_uniqueStorage()._company = newValue}
  }
  /// Returns true if `company` has been explicitly set.
  var hasCompany: Bool {return _storage._company != nil}
  /// Clears the value of `company`. Subsequent reads from it will return its default value.
  mutating func clearCompany() {_uniqueStorage()._company = nil}

  var focus: String {
    get {return _storage._focus}
    set {_uniqueStorage()._focus = newValue}
  }

  var passed: Bool {
    get {return _storage._passed}
    set {_uniqueStorage()._passed = newValue}
  }

  var result: String {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  var contacts: [Io_Openisms_V1_Person] {
    get {return _storage._contacts}
    set {_uniqueStorage()._contacts = newValue}
  }

  var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Openisms_V1_Repository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var url: String = String()

  var description_p: String = String()

  var visibility: Io_Openisms_V1_Visibility = .undefined

  var members: [Io_Openisms_V1_Person] = []

  /// branch-protection
  var securityAttributes: [String] = []

  var tags: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Openisms_V1_Statistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// accounts:num_users, device_management:num_30day_desktop_linux_managed_devices
  var identifier: String = String()

  /// Number of users
  var name: String = String()

  /// 42
  var value: Int32 = 0

  /// "Does not include suspended users"
  var comment: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Io_Openisms_V1_Visibility: @unchecked Sendable {}
extension Io_Openisms_V1_Event: @unchecked Sendable {}
extension Io_Openisms_V1_Meta: @unchecked Sendable {}
extension Io_Openisms_V1_SourceSystem: @unchecked Sendable {}
extension Io_Openisms_V1_SourceSystem.SourceType: @unchecked Sendable {}
extension Io_Openisms_V1_User: @unchecked Sendable {}
extension Io_Openisms_V1_Person: @unchecked Sendable {}
extension Io_Openisms_V1_Name: @unchecked Sendable {}
extension Io_Openisms_V1_UrlWithEtag: @unchecked Sendable {}
extension Io_Openisms_V1_Employment: @unchecked Sendable {}
extension Io_Openisms_V1_ConnectedAccount: @unchecked Sendable {}
extension Io_Openisms_V1_PhysicalObject: @unchecked Sendable {}
extension Io_Openisms_V1_SecurityFeatures: @unchecked Sendable {}
extension Io_Openisms_V1_Network: @unchecked Sendable {}
extension Io_Openisms_V1_OperatingSystem: @unchecked Sendable {}
extension Io_Openisms_V1_OperatingSystem.OperatingSystems: @unchecked Sendable {}
extension Io_Openisms_V1_Application: @unchecked Sendable {}
extension Io_Openisms_V1_Profile: @unchecked Sendable {}
extension Io_Openisms_V1_Date: @unchecked Sendable {}
extension Io_Openisms_V1_Certification: @unchecked Sendable {}
extension Io_Openisms_V1_Company: @unchecked Sendable {}
extension Io_Openisms_V1_Pentest: @unchecked Sendable {}
extension Io_Openisms_V1_Repository: @unchecked Sendable {}
extension Io_Openisms_V1_Statistics: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "io.openisms.v1"

extension Io_Openisms_V1_Visibility: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "undefined"),
    1: .same(proto: "public"),
    2: .same(proto: "internal"),
    3: .same(proto: "confidential"),
  ]
}

extension Io_Openisms_V1_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "meta"),
    2: .same(proto: "source"),
    3: .same(proto: "users"),
    4: .same(proto: "devices"),
    7: .same(proto: "repositories"),
    9: .same(proto: "certification"),
    11: .same(proto: "pentest"),
    13: .same(proto: "stats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._meta) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.repositories) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.certification) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.pentest) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.stats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._meta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 3)
    }
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 4)
    }
    if !self.repositories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.repositories, fieldNumber: 7)
    }
    if !self.certification.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.certification, fieldNumber: 9)
    }
    if !self.pentest.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pentest, fieldNumber: 11)
    }
    if !self.stats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stats, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Event, rhs: Io_Openisms_V1_Event) -> Bool {
    if lhs._meta != rhs._meta {return false}
    if lhs._source != rhs._source {return false}
    if lhs.users != rhs.users {return false}
    if lhs.devices != rhs.devices {return false}
    if lhs.repositories != rhs.repositories {return false}
    if lhs.certification != rhs.certification {return false}
    if lhs.pentest != rhs.pentest {return false}
    if lhs.stats != rhs.stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_Meta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Meta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "created"),
    2: .same(proto: "identifier"),
    3: .same(proto: "etag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._created) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._created {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 2)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Meta, rhs: Io_Openisms_V1_Meta) -> Bool {
    if lhs._created != rhs._created {return false}
    if lhs.identifier != rhs.identifier {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_SourceSystem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SourceSystem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "vendor"),
    3: .same(proto: "url"),
    4: .standard(proto: "logo_url"),
    5: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.vendor) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.logoURL) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.vendor.isEmpty {
      try visitor.visitSingularStringField(value: self.vendor, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    if !self.logoURL.isEmpty {
      try visitor.visitSingularStringField(value: self.logoURL, fieldNumber: 4)
    }
    if self.type != .undefined {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_SourceSystem, rhs: Io_Openisms_V1_SourceSystem) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.vendor != rhs.vendor {return false}
    if lhs.url != rhs.url {return false}
    if lhs.logoURL != rhs.logoURL {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_SourceSystem.SourceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "undefined"),
    1: .same(proto: "identity_provider"),
    2: .same(proto: "source_control_management"),
    3: .same(proto: "cloud_provider"),
    4: .same(proto: "database"),
    5: .same(proto: "network"),
    10: .same(proto: "device_management"),
    11: .same(proto: "security_software"),
    12: .same(proto: "password_manager"),
    20: .same(proto: "communication"),
    21: .same(proto: "human_resources"),
    22: .same(proto: "content_management_system"),
    23: .same(proto: "ticketing"),
    24: .same(proto: "customer_relationship_management"),
    25: .same(proto: "finance"),
    26: .same(proto: "analytics"),
  ]
}

extension Io_Openisms_V1_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "person"),
    5: .standard(proto: "second_factor_active"),
    6: .standard(proto: "second_factor_enforced"),
    7: .same(proto: "active"),
    8: .same(proto: "suspended"),
    9: .same(proto: "disabled"),
    10: .same(proto: "deleted"),
    15: .same(proto: "groups"),
    16: .same(proto: "privileges"),
    20: .same(proto: "employment"),
    21: .standard(proto: "connected_accounts"),
    22: .same(proto: "possessions"),
    40: .same(proto: "tags"),
  ]

  fileprivate class _StorageClass {
    var _person: Io_Openisms_V1_Person? = nil
    var _secondFactorActive: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _secondFactorEnforced: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _active: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _suspended: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _disabled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _deleted: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _groups: [String] = []
    var _privileges: [String] = []
    var _employment: Io_Openisms_V1_Employment? = nil
    var _connectedAccounts: [Io_Openisms_V1_ConnectedAccount] = []
    var _possessions: [Io_Openisms_V1_PhysicalObject] = []
    var _tags: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _person = source._person
      _secondFactorActive = source._secondFactorActive
      _secondFactorEnforced = source._secondFactorEnforced
      _active = source._active
      _suspended = source._suspended
      _disabled = source._disabled
      _deleted = source._deleted
      _groups = source._groups
      _privileges = source._privileges
      _employment = source._employment
      _connectedAccounts = source._connectedAccounts
      _possessions = source._possessions
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._person) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._secondFactorActive) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._secondFactorEnforced) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._active) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._suspended) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._disabled) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._deleted) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._groups) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._privileges) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._employment) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._connectedAccounts) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._possessions) }()
        case 40: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._person {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._secondFactorActive {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._secondFactorEnforced {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._active {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._suspended {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._disabled {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._deleted {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._groups.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._groups, fieldNumber: 15)
      }
      if !_storage._privileges.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._privileges, fieldNumber: 16)
      }
      try { if let v = _storage._employment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._connectedAccounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._connectedAccounts, fieldNumber: 21)
      }
      if !_storage._possessions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._possessions, fieldNumber: 22)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 40)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_User, rhs: Io_Openisms_V1_User) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._person != rhs_storage._person {return false}
        if _storage._secondFactorActive != rhs_storage._secondFactorActive {return false}
        if _storage._secondFactorEnforced != rhs_storage._secondFactorEnforced {return false}
        if _storage._active != rhs_storage._active {return false}
        if _storage._suspended != rhs_storage._suspended {return false}
        if _storage._disabled != rhs_storage._disabled {return false}
        if _storage._deleted != rhs_storage._deleted {return false}
        if _storage._groups != rhs_storage._groups {return false}
        if _storage._privileges != rhs_storage._privileges {return false}
        if _storage._employment != rhs_storage._employment {return false}
        if _storage._connectedAccounts != rhs_storage._connectedAccounts {return false}
        if _storage._possessions != rhs_storage._possessions {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_Person: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Person"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "primary_email"),
    4: .standard(proto: "other_emails"),
    5: .same(proto: "picture"),
    6: .same(proto: "company"),
    10: .same(proto: "created"),
    11: .same(proto: "updated"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: Io_Openisms_V1_Name? = nil
    var _primaryEmail: String = String()
    var _otherEmails: [String] = []
    var _picture: Io_Openisms_V1_UrlWithEtag? = nil
    var _company: String = String()
    var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _primaryEmail = source._primaryEmail
      _otherEmails = source._otherEmails
      _picture = source._picture
      _company = source._company
      _created = source._created
      _updated = source._updated
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._primaryEmail) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._otherEmails) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._picture) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._company) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._created) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._updated) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._primaryEmail.isEmpty {
        try visitor.visitSingularStringField(value: _storage._primaryEmail, fieldNumber: 3)
      }
      if !_storage._otherEmails.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._otherEmails, fieldNumber: 4)
      }
      try { if let v = _storage._picture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._company.isEmpty {
        try visitor.visitSingularStringField(value: _storage._company, fieldNumber: 6)
      }
      try { if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._updated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Person, rhs: Io_Openisms_V1_Person) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._primaryEmail != rhs_storage._primaryEmail {return false}
        if _storage._otherEmails != rhs_storage._otherEmails {return false}
        if _storage._picture != rhs_storage._picture {return false}
        if _storage._company != rhs_storage._company {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._updated != rhs_storage._updated {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Name"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "given_name"),
    2: .standard(proto: "family_name"),
    3: .standard(proto: "full_name"),
    4: .same(proto: "title"),
    5: .same(proto: "position"),
    6: .same(proto: "role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.givenName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.familyName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fullName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.position) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.givenName.isEmpty {
      try visitor.visitSingularStringField(value: self.givenName, fieldNumber: 1)
    }
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 2)
    }
    if !self.fullName.isEmpty {
      try visitor.visitSingularStringField(value: self.fullName, fieldNumber: 3)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    if !self.position.isEmpty {
      try visitor.visitSingularStringField(value: self.position, fieldNumber: 5)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Name, rhs: Io_Openisms_V1_Name) -> Bool {
    if lhs.givenName != rhs.givenName {return false}
    if lhs.familyName != rhs.familyName {return false}
    if lhs.fullName != rhs.fullName {return false}
    if lhs.title != rhs.title {return false}
    if lhs.position != rhs.position {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_UrlWithEtag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UrlWithEtag"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "etag"),
    3: .standard(proto: "last_modified"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastModified) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 2)
    }
    try { if let v = self._lastModified {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_UrlWithEtag, rhs: Io_Openisms_V1_UrlWithEtag) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs._lastModified != rhs._lastModified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_Employment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Employment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contract"),
    2: .same(proto: "status"),
    3: .same(proto: "begin"),
    4: .same(proto: "end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contract) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._begin) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contract.isEmpty {
      try visitor.visitSingularStringField(value: self.contract, fieldNumber: 1)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 2)
    }
    try { if let v = self._begin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Employment, rhs: Io_Openisms_V1_Employment) -> Bool {
    if lhs.contract != rhs.contract {return false}
    if lhs.status != rhs.status {return false}
    if lhs._begin != rhs._begin {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_ConnectedAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectedAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "app_name"),
    3: .standard(proto: "app_type"),
    4: .standard(proto: "app_url"),
    5: .standard(proto: "user_id"),
    6: .same(proto: "scopes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.appURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.scopes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    if !self.appName.isEmpty {
      try visitor.visitSingularStringField(value: self.appName, fieldNumber: 2)
    }
    if !self.appType.isEmpty {
      try visitor.visitSingularStringField(value: self.appType, fieldNumber: 3)
    }
    if !self.appURL.isEmpty {
      try visitor.visitSingularStringField(value: self.appURL, fieldNumber: 4)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 5)
    }
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_ConnectedAccount, rhs: Io_Openisms_V1_ConnectedAccount) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.appName != rhs.appName {return false}
    if lhs.appType != rhs.appType {return false}
    if lhs.appURL != rhs.appURL {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_PhysicalObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PhysicalObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "name"),
    3: .same(proto: "manufacturer"),
    4: .same(proto: "vendor"),
    5: .same(proto: "identifier"),
    6: .standard(proto: "serial_number"),
    7: .same(proto: "imei"),
    8: .same(proto: "meid"),
    9: .same(proto: "networks"),
    10: .same(proto: "hostname"),
    11: .standard(proto: "user_accounts"),
    12: .same(proto: "os"),
    13: .same(proto: "security"),
    14: .same(proto: "profiles"),
    15: .same(proto: "apps"),
    20: .same(proto: "tags"),
  ]

  fileprivate class _StorageClass {
    var _type: String = String()
    var _name: String = String()
    var _manufacturer: String = String()
    var _vendor: String = String()
    var _identifier: String = String()
    var _serialNumber: String = String()
    var _imei: String = String()
    var _meid: String = String()
    var _networks: [Io_Openisms_V1_Network] = []
    var _hostname: String = String()
    var _userAccounts: [String] = []
    var _os: Io_Openisms_V1_OperatingSystem? = nil
    var _security: Io_Openisms_V1_SecurityFeatures? = nil
    var _profiles: [Io_Openisms_V1_Profile] = []
    var _apps: [Io_Openisms_V1_Application] = []
    var _tags: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _name = source._name
      _manufacturer = source._manufacturer
      _vendor = source._vendor
      _identifier = source._identifier
      _serialNumber = source._serialNumber
      _imei = source._imei
      _meid = source._meid
      _networks = source._networks
      _hostname = source._hostname
      _userAccounts = source._userAccounts
      _os = source._os
      _security = source._security
      _profiles = source._profiles
      _apps = source._apps
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._manufacturer) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._vendor) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._identifier) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._serialNumber) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._imei) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._meid) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._networks) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._hostname) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._userAccounts) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._os) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._security) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._profiles) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._apps) }()
        case 20: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._manufacturer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._manufacturer, fieldNumber: 3)
      }
      if !_storage._vendor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vendor, fieldNumber: 4)
      }
      if !_storage._identifier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identifier, fieldNumber: 5)
      }
      if !_storage._serialNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serialNumber, fieldNumber: 6)
      }
      if !_storage._imei.isEmpty {
        try visitor.visitSingularStringField(value: _storage._imei, fieldNumber: 7)
      }
      if !_storage._meid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._meid, fieldNumber: 8)
      }
      if !_storage._networks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._networks, fieldNumber: 9)
      }
      if !_storage._hostname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostname, fieldNumber: 10)
      }
      if !_storage._userAccounts.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._userAccounts, fieldNumber: 11)
      }
      try { if let v = _storage._os {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._security {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._profiles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._profiles, fieldNumber: 14)
      }
      if !_storage._apps.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._apps, fieldNumber: 15)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_PhysicalObject, rhs: Io_Openisms_V1_PhysicalObject) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._manufacturer != rhs_storage._manufacturer {return false}
        if _storage._vendor != rhs_storage._vendor {return false}
        if _storage._identifier != rhs_storage._identifier {return false}
        if _storage._serialNumber != rhs_storage._serialNumber {return false}
        if _storage._imei != rhs_storage._imei {return false}
        if _storage._meid != rhs_storage._meid {return false}
        if _storage._networks != rhs_storage._networks {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._userAccounts != rhs_storage._userAccounts {return false}
        if _storage._os != rhs_storage._os {return false}
        if _storage._security != rhs_storage._security {return false}
        if _storage._profiles != rhs_storage._profiles {return false}
        if _storage._apps != rhs_storage._apps {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_SecurityFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SecurityFeatures"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "activation_lock"),
    2: .same(proto: "supervised"),
    3: .standard(proto: "file_vault"),
    4: .standard(proto: "full_disk_encryption"),
    5: .standard(proto: "secure_password"),
    6: .standard(proto: "automatic_screen_lock"),
    7: .standard(proto: "screen_lock_after"),
    8: .standard(proto: "firewall_enabled"),
    9: .standard(proto: "automatic_updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._activationLock) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._supervised) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fileVault) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._fullDiskEncryption) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._securePassword) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._automaticScreenLock) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._screenLockAfter) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._firewallEnabled) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._automaticUpdates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._activationLock {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._supervised {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fileVault {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._fullDiskEncryption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._securePassword {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._automaticScreenLock {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._screenLockAfter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._firewallEnabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._automaticUpdates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_SecurityFeatures, rhs: Io_Openisms_V1_SecurityFeatures) -> Bool {
    if lhs._activationLock != rhs._activationLock {return false}
    if lhs._supervised != rhs._supervised {return false}
    if lhs._fileVault != rhs._fileVault {return false}
    if lhs._fullDiskEncryption != rhs._fullDiskEncryption {return false}
    if lhs._securePassword != rhs._securePassword {return false}
    if lhs._automaticScreenLock != rhs._automaticScreenLock {return false}
    if lhs._screenLockAfter != rhs._screenLockAfter {return false}
    if lhs._firewallEnabled != rhs._firewallEnabled {return false}
    if lhs._automaticUpdates != rhs._automaticUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_Network: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Network"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .standard(proto: "mac_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.macAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.macAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.macAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Network, rhs: Io_Openisms_V1_Network) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.macAddress != rhs.macAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_OperatingSystem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OperatingSystem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "os"),
    2: .standard(proto: "major_version"),
    3: .standard(proto: "full_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.os) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.majorVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fullVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.os != .undefined {
      try visitor.visitSingularEnumField(value: self.os, fieldNumber: 1)
    }
    if !self.majorVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.majorVersion, fieldNumber: 2)
    }
    if !self.fullVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.fullVersion, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_OperatingSystem, rhs: Io_Openisms_V1_OperatingSystem) -> Bool {
    if lhs.os != rhs.os {return false}
    if lhs.majorVersion != rhs.majorVersion {return false}
    if lhs.fullVersion != rhs.fullVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_OperatingSystem.OperatingSystems: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "undefined"),
    1: .same(proto: "macos"),
    2: .same(proto: "windows"),
    3: .same(proto: "linux"),
    4: .same(proto: "unix"),
    5: .same(proto: "chrome_os"),
    10: .same(proto: "ios"),
    11: .same(proto: "android"),
    14: .same(proto: "ros"),
    15: .same(proto: "other"),
  ]
}

extension Io_Openisms_V1_Application: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Application"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "path"),
    3: .same(proto: "vendor"),
    4: .same(proto: "url"),
    5: .same(proto: "description"),
    6: .same(proto: "version"),
    7: .same(proto: "signed"),
    8: .standard(proto: "system_app"),
    9: .standard(proto: "installation_source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.vendor) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._signed) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._systemApp) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.installationSource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if !self.vendor.isEmpty {
      try visitor.visitSingularStringField(value: self.vendor, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 6)
    }
    try { if let v = self._signed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._systemApp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.installationSource.isEmpty {
      try visitor.visitSingularStringField(value: self.installationSource, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Application, rhs: Io_Openisms_V1_Application) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.path != rhs.path {return false}
    if lhs.vendor != rhs.vendor {return false}
    if lhs.url != rhs.url {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.version != rhs.version {return false}
    if lhs._signed != rhs._signed {return false}
    if lhs._systemApp != rhs._systemApp {return false}
    if lhs.installationSource != rhs.installationSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_Profile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Profile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "identifier"),
    3: .standard(proto: "removal_allowed"),
    4: .standard(proto: "payload_type"),
    5: .standard(proto: "payload_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._removalAllowed) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.payloadType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.payloadIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 2)
    }
    try { if let v = self._removalAllowed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.payloadType.isEmpty {
      try visitor.visitSingularStringField(value: self.payloadType, fieldNumber: 4)
    }
    if !self.payloadIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.payloadIdentifier, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Profile, rhs: Io_Openisms_V1_Profile) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.identifier != rhs.identifier {return false}
    if lhs._removalAllowed != rhs._removalAllowed {return false}
    if lhs.payloadType != rhs.payloadType {return false}
    if lhs.payloadIdentifier != rhs.payloadIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_Date: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Date"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "day"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.year) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.month) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.day) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularInt32Field(value: self.month, fieldNumber: 2)
    }
    if self.day != 0 {
      try visitor.visitSingularInt32Field(value: self.day, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Date, rhs: Io_Openisms_V1_Date) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_Certification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Certification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "url"),
    10: .same(proto: "tags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Certification, rhs: Io_Openisms_V1_Certification) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.url != rhs.url {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_Company: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Company"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
    3: .same(proto: "category"),
    4: .same(proto: "contact"),
    5: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._contact) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 3)
    }
    try { if let v = self._contact {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.address.isEmpty {
      try visitor.visitRepeatedStringField(value: self.address, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Company, rhs: Io_Openisms_V1_Company) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.category != rhs.category {return false}
    if lhs._contact != rhs._contact {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_Pentest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pentest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "begin"),
    3: .same(proto: "end"),
    4: .same(proto: "company"),
    5: .same(proto: "focus"),
    6: .same(proto: "passed"),
    7: .same(proto: "result"),
    8: .same(proto: "url"),
    9: .same(proto: "contacts"),
    10: .same(proto: "tags"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _begin: Io_Openisms_V1_Date? = nil
    var _end: Io_Openisms_V1_Date? = nil
    var _company: Io_Openisms_V1_Company? = nil
    var _focus: String = String()
    var _passed: Bool = false
    var _result: String = String()
    var _url: String = String()
    var _contacts: [Io_Openisms_V1_Person] = []
    var _tags: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _begin = source._begin
      _end = source._end
      _company = source._company
      _focus = source._focus
      _passed = source._passed
      _result = source._result
      _url = source._url
      _contacts = source._contacts
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._begin) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._end) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._company) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._focus) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._passed) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._result) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._contacts) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._begin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._end {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._company {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._focus.isEmpty {
        try visitor.visitSingularStringField(value: _storage._focus, fieldNumber: 5)
      }
      if _storage._passed != false {
        try visitor.visitSingularBoolField(value: _storage._passed, fieldNumber: 6)
      }
      if !_storage._result.isEmpty {
        try visitor.visitSingularStringField(value: _storage._result, fieldNumber: 7)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 8)
      }
      if !_storage._contacts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._contacts, fieldNumber: 9)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Pentest, rhs: Io_Openisms_V1_Pentest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._begin != rhs_storage._begin {return false}
        if _storage._end != rhs_storage._end {return false}
        if _storage._company != rhs_storage._company {return false}
        if _storage._focus != rhs_storage._focus {return false}
        if _storage._passed != rhs_storage._passed {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._contacts != rhs_storage._contacts {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_Repository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Repository"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
    3: .same(proto: "description"),
    4: .same(proto: "visibility"),
    5: .same(proto: "members"),
    6: .standard(proto: "security_attributes"),
    10: .same(proto: "tags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.visibility) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.securityAttributes) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.visibility != .undefined {
      try visitor.visitSingularEnumField(value: self.visibility, fieldNumber: 4)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 5)
    }
    if !self.securityAttributes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.securityAttributes, fieldNumber: 6)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Repository, rhs: Io_Openisms_V1_Repository) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.visibility != rhs.visibility {return false}
    if lhs.members != rhs.members {return false}
    if lhs.securityAttributes != rhs.securityAttributes {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Openisms_V1_Statistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Statistics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "name"),
    3: .same(proto: "value"),
    4: .same(proto: "comment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 3)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Openisms_V1_Statistics, rhs: Io_Openisms_V1_Statistics) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
