// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: io/openisms/api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_io_2fopenisms_2fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_io_2fopenisms_2fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_io_2fopenisms_2fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_io_2fopenisms_2fapi_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_io_2fopenisms_2fapi_2eproto;
namespace io {
namespace openisms {
namespace v1 {
class Application;
struct ApplicationDefaultTypeInternal;
extern ApplicationDefaultTypeInternal _Application_default_instance_;
class Certification;
struct CertificationDefaultTypeInternal;
extern CertificationDefaultTypeInternal _Certification_default_instance_;
class Company;
struct CompanyDefaultTypeInternal;
extern CompanyDefaultTypeInternal _Company_default_instance_;
class ConnectedAccount;
struct ConnectedAccountDefaultTypeInternal;
extern ConnectedAccountDefaultTypeInternal _ConnectedAccount_default_instance_;
class Date;
struct DateDefaultTypeInternal;
extern DateDefaultTypeInternal _Date_default_instance_;
class Employment;
struct EmploymentDefaultTypeInternal;
extern EmploymentDefaultTypeInternal _Employment_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Meta;
struct MetaDefaultTypeInternal;
extern MetaDefaultTypeInternal _Meta_default_instance_;
class Name;
struct NameDefaultTypeInternal;
extern NameDefaultTypeInternal _Name_default_instance_;
class Network;
struct NetworkDefaultTypeInternal;
extern NetworkDefaultTypeInternal _Network_default_instance_;
class OperatingSystem;
struct OperatingSystemDefaultTypeInternal;
extern OperatingSystemDefaultTypeInternal _OperatingSystem_default_instance_;
class Pentest;
struct PentestDefaultTypeInternal;
extern PentestDefaultTypeInternal _Pentest_default_instance_;
class Person;
struct PersonDefaultTypeInternal;
extern PersonDefaultTypeInternal _Person_default_instance_;
class Photo;
struct PhotoDefaultTypeInternal;
extern PhotoDefaultTypeInternal _Photo_default_instance_;
class PhysicalObject;
struct PhysicalObjectDefaultTypeInternal;
extern PhysicalObjectDefaultTypeInternal _PhysicalObject_default_instance_;
class Profile;
struct ProfileDefaultTypeInternal;
extern ProfileDefaultTypeInternal _Profile_default_instance_;
class Repository;
struct RepositoryDefaultTypeInternal;
extern RepositoryDefaultTypeInternal _Repository_default_instance_;
class SecurityFeatures;
struct SecurityFeaturesDefaultTypeInternal;
extern SecurityFeaturesDefaultTypeInternal _SecurityFeatures_default_instance_;
class SourceSystem;
struct SourceSystemDefaultTypeInternal;
extern SourceSystemDefaultTypeInternal _SourceSystem_default_instance_;
class Statistics;
struct StatisticsDefaultTypeInternal;
extern StatisticsDefaultTypeInternal _Statistics_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace v1
}  // namespace openisms
}  // namespace io
PROTOBUF_NAMESPACE_OPEN
template<> ::io::openisms::v1::Application* Arena::CreateMaybeMessage<::io::openisms::v1::Application>(Arena*);
template<> ::io::openisms::v1::Certification* Arena::CreateMaybeMessage<::io::openisms::v1::Certification>(Arena*);
template<> ::io::openisms::v1::Company* Arena::CreateMaybeMessage<::io::openisms::v1::Company>(Arena*);
template<> ::io::openisms::v1::ConnectedAccount* Arena::CreateMaybeMessage<::io::openisms::v1::ConnectedAccount>(Arena*);
template<> ::io::openisms::v1::Date* Arena::CreateMaybeMessage<::io::openisms::v1::Date>(Arena*);
template<> ::io::openisms::v1::Employment* Arena::CreateMaybeMessage<::io::openisms::v1::Employment>(Arena*);
template<> ::io::openisms::v1::Event* Arena::CreateMaybeMessage<::io::openisms::v1::Event>(Arena*);
template<> ::io::openisms::v1::Meta* Arena::CreateMaybeMessage<::io::openisms::v1::Meta>(Arena*);
template<> ::io::openisms::v1::Name* Arena::CreateMaybeMessage<::io::openisms::v1::Name>(Arena*);
template<> ::io::openisms::v1::Network* Arena::CreateMaybeMessage<::io::openisms::v1::Network>(Arena*);
template<> ::io::openisms::v1::OperatingSystem* Arena::CreateMaybeMessage<::io::openisms::v1::OperatingSystem>(Arena*);
template<> ::io::openisms::v1::Pentest* Arena::CreateMaybeMessage<::io::openisms::v1::Pentest>(Arena*);
template<> ::io::openisms::v1::Person* Arena::CreateMaybeMessage<::io::openisms::v1::Person>(Arena*);
template<> ::io::openisms::v1::Photo* Arena::CreateMaybeMessage<::io::openisms::v1::Photo>(Arena*);
template<> ::io::openisms::v1::PhysicalObject* Arena::CreateMaybeMessage<::io::openisms::v1::PhysicalObject>(Arena*);
template<> ::io::openisms::v1::Profile* Arena::CreateMaybeMessage<::io::openisms::v1::Profile>(Arena*);
template<> ::io::openisms::v1::Repository* Arena::CreateMaybeMessage<::io::openisms::v1::Repository>(Arena*);
template<> ::io::openisms::v1::SecurityFeatures* Arena::CreateMaybeMessage<::io::openisms::v1::SecurityFeatures>(Arena*);
template<> ::io::openisms::v1::SourceSystem* Arena::CreateMaybeMessage<::io::openisms::v1::SourceSystem>(Arena*);
template<> ::io::openisms::v1::Statistics* Arena::CreateMaybeMessage<::io::openisms::v1::Statistics>(Arena*);
template<> ::io::openisms::v1::User* Arena::CreateMaybeMessage<::io::openisms::v1::User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace io {
namespace openisms {
namespace v1 {

enum SourceSystem_SourceType : int {
  SourceSystem_SourceType_undefined = 0,
  SourceSystem_SourceType_identity_provider = 1,
  SourceSystem_SourceType_source_control_management = 2,
  SourceSystem_SourceType_cloud_provider = 3,
  SourceSystem_SourceType_database = 4,
  SourceSystem_SourceType_network = 5,
  SourceSystem_SourceType_device_management = 10,
  SourceSystem_SourceType_security_software = 11,
  SourceSystem_SourceType_password_manager = 12,
  SourceSystem_SourceType_communication = 20,
  SourceSystem_SourceType_human_resources = 21,
  SourceSystem_SourceType_content_management_system = 22,
  SourceSystem_SourceType_ticketing = 23,
  SourceSystem_SourceType_customer_relationship_management = 24,
  SourceSystem_SourceType_finance = 25,
  SourceSystem_SourceType_analytics = 26,
  SourceSystem_SourceType_SourceSystem_SourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SourceSystem_SourceType_SourceSystem_SourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SourceSystem_SourceType_IsValid(int value);
constexpr SourceSystem_SourceType SourceSystem_SourceType_SourceType_MIN = SourceSystem_SourceType_undefined;
constexpr SourceSystem_SourceType SourceSystem_SourceType_SourceType_MAX = SourceSystem_SourceType_analytics;
constexpr int SourceSystem_SourceType_SourceType_ARRAYSIZE = SourceSystem_SourceType_SourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SourceSystem_SourceType_descriptor();
template<typename T>
inline const std::string& SourceSystem_SourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SourceSystem_SourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SourceSystem_SourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SourceSystem_SourceType_descriptor(), enum_t_value);
}
inline bool SourceSystem_SourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SourceSystem_SourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SourceSystem_SourceType>(
    SourceSystem_SourceType_descriptor(), name, value);
}
enum OperatingSystem_OperatingSystems : int {
  OperatingSystem_OperatingSystems_undefined = 0,
  OperatingSystem_OperatingSystems_macos = 1,
  OperatingSystem_OperatingSystems_windows = 2,
  OperatingSystem_OperatingSystems_linux = 3,
  OperatingSystem_OperatingSystems_unix = 4,
  OperatingSystem_OperatingSystems_chrome_os = 5,
  OperatingSystem_OperatingSystems_ios = 10,
  OperatingSystem_OperatingSystems_android = 11,
  OperatingSystem_OperatingSystems_ros = 14,
  OperatingSystem_OperatingSystems_other = 15,
  OperatingSystem_OperatingSystems_OperatingSystem_OperatingSystems_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OperatingSystem_OperatingSystems_OperatingSystem_OperatingSystems_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OperatingSystem_OperatingSystems_IsValid(int value);
constexpr OperatingSystem_OperatingSystems OperatingSystem_OperatingSystems_OperatingSystems_MIN = OperatingSystem_OperatingSystems_undefined;
constexpr OperatingSystem_OperatingSystems OperatingSystem_OperatingSystems_OperatingSystems_MAX = OperatingSystem_OperatingSystems_other;
constexpr int OperatingSystem_OperatingSystems_OperatingSystems_ARRAYSIZE = OperatingSystem_OperatingSystems_OperatingSystems_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperatingSystem_OperatingSystems_descriptor();
template<typename T>
inline const std::string& OperatingSystem_OperatingSystems_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OperatingSystem_OperatingSystems>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OperatingSystem_OperatingSystems_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OperatingSystem_OperatingSystems_descriptor(), enum_t_value);
}
inline bool OperatingSystem_OperatingSystems_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OperatingSystem_OperatingSystems* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OperatingSystem_OperatingSystems>(
    OperatingSystem_OperatingSystems_descriptor(), name, value);
}
enum Visibility : int {
  undefined = 0,
  public_ = 1,
  internal = 2,
  confidential = 3,
  Visibility_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Visibility_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Visibility_IsValid(int value);
constexpr Visibility Visibility_MIN = undefined;
constexpr Visibility Visibility_MAX = confidential;
constexpr int Visibility_ARRAYSIZE = Visibility_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Visibility_descriptor();
template<typename T>
inline const std::string& Visibility_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Visibility>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Visibility_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Visibility_descriptor(), enum_t_value);
}
inline bool Visibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Visibility* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Visibility>(
    Visibility_descriptor(), name, value);
}
// ===================================================================

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit PROTOBUF_CONSTEXPR Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Event& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 3,
    kDevicesFieldNumber = 4,
    kRepositoriesFieldNumber = 7,
    kCertificationFieldNumber = 9,
    kPentestFieldNumber = 11,
    kStatsFieldNumber = 13,
    kMetaFieldNumber = 1,
    kSourceFieldNumber = 2,
  };
  // repeated .io.openisms.v1.User users = 3;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::io::openisms::v1::User* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::User >*
      mutable_users();
  private:
  const ::io::openisms::v1::User& _internal_users(int index) const;
  ::io::openisms::v1::User* _internal_add_users();
  public:
  const ::io::openisms::v1::User& users(int index) const;
  ::io::openisms::v1::User* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::User >&
      users() const;

  // repeated .io.openisms.v1.PhysicalObject devices = 4;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::io::openisms::v1::PhysicalObject* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::PhysicalObject >*
      mutable_devices();
  private:
  const ::io::openisms::v1::PhysicalObject& _internal_devices(int index) const;
  ::io::openisms::v1::PhysicalObject* _internal_add_devices();
  public:
  const ::io::openisms::v1::PhysicalObject& devices(int index) const;
  ::io::openisms::v1::PhysicalObject* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::PhysicalObject >&
      devices() const;

  // repeated .io.openisms.v1.Repository repositories = 7;
  int repositories_size() const;
  private:
  int _internal_repositories_size() const;
  public:
  void clear_repositories();
  ::io::openisms::v1::Repository* mutable_repositories(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Repository >*
      mutable_repositories();
  private:
  const ::io::openisms::v1::Repository& _internal_repositories(int index) const;
  ::io::openisms::v1::Repository* _internal_add_repositories();
  public:
  const ::io::openisms::v1::Repository& repositories(int index) const;
  ::io::openisms::v1::Repository* add_repositories();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Repository >&
      repositories() const;

  // repeated .io.openisms.v1.Certification certification = 9;
  int certification_size() const;
  private:
  int _internal_certification_size() const;
  public:
  void clear_certification();
  ::io::openisms::v1::Certification* mutable_certification(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Certification >*
      mutable_certification();
  private:
  const ::io::openisms::v1::Certification& _internal_certification(int index) const;
  ::io::openisms::v1::Certification* _internal_add_certification();
  public:
  const ::io::openisms::v1::Certification& certification(int index) const;
  ::io::openisms::v1::Certification* add_certification();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Certification >&
      certification() const;

  // repeated .io.openisms.v1.Pentest pentest = 11;
  int pentest_size() const;
  private:
  int _internal_pentest_size() const;
  public:
  void clear_pentest();
  ::io::openisms::v1::Pentest* mutable_pentest(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Pentest >*
      mutable_pentest();
  private:
  const ::io::openisms::v1::Pentest& _internal_pentest(int index) const;
  ::io::openisms::v1::Pentest* _internal_add_pentest();
  public:
  const ::io::openisms::v1::Pentest& pentest(int index) const;
  ::io::openisms::v1::Pentest* add_pentest();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Pentest >&
      pentest() const;

  // repeated .io.openisms.v1.Statistics stats = 13;
  int stats_size() const;
  private:
  int _internal_stats_size() const;
  public:
  void clear_stats();
  ::io::openisms::v1::Statistics* mutable_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Statistics >*
      mutable_stats();
  private:
  const ::io::openisms::v1::Statistics& _internal_stats(int index) const;
  ::io::openisms::v1::Statistics* _internal_add_stats();
  public:
  const ::io::openisms::v1::Statistics& stats(int index) const;
  ::io::openisms::v1::Statistics* add_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Statistics >&
      stats() const;

  // .io.openisms.v1.Meta meta = 1;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::io::openisms::v1::Meta& meta() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::Meta* release_meta();
  ::io::openisms::v1::Meta* mutable_meta();
  void set_allocated_meta(::io::openisms::v1::Meta* meta);
  private:
  const ::io::openisms::v1::Meta& _internal_meta() const;
  ::io::openisms::v1::Meta* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::io::openisms::v1::Meta* meta);
  ::io::openisms::v1::Meta* unsafe_arena_release_meta();

  // .io.openisms.v1.SourceSystem source = 2;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::io::openisms::v1::SourceSystem& source() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::SourceSystem* release_source();
  ::io::openisms::v1::SourceSystem* mutable_source();
  void set_allocated_source(::io::openisms::v1::SourceSystem* source);
  private:
  const ::io::openisms::v1::SourceSystem& _internal_source() const;
  ::io::openisms::v1::SourceSystem* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::io::openisms::v1::SourceSystem* source);
  ::io::openisms::v1::SourceSystem* unsafe_arena_release_source();

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::User > users_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::PhysicalObject > devices_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Repository > repositories_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Certification > certification_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Pentest > pentest_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Statistics > stats_;
  ::io::openisms::v1::Meta* meta_;
  ::io::openisms::v1::SourceSystem* source_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Meta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Meta) */ {
 public:
  inline Meta() : Meta(nullptr) {}
  ~Meta() override;
  explicit PROTOBUF_CONSTEXPR Meta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Meta(const Meta& from);
  Meta(Meta&& from) noexcept
    : Meta() {
    *this = ::std::move(from);
  }

  inline Meta& operator=(const Meta& from) {
    CopyFrom(from);
    return *this;
  }
  inline Meta& operator=(Meta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Meta& default_instance() {
    return *internal_default_instance();
  }
  static inline const Meta* internal_default_instance() {
    return reinterpret_cast<const Meta*>(
               &_Meta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Meta& a, Meta& b) {
    a.Swap(&b);
  }
  inline void Swap(Meta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Meta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Meta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Meta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Meta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Meta& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Meta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Meta";
  }
  protected:
  explicit Meta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 2,
    kEtagFieldNumber = 3,
    kCreatedFieldNumber = 1,
  };
  // string identifier = 2;
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // string etag = 3;
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // .google.protobuf.Timestamp created = 1;
  bool has_created() const;
  private:
  bool _internal_has_created() const;
  public:
  void clear_created();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created();
  void set_allocated_created(::PROTOBUF_NAMESPACE_ID::Timestamp* created);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created();
  public:
  void unsafe_arena_set_allocated_created(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created();

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Meta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class SourceSystem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.SourceSystem) */ {
 public:
  inline SourceSystem() : SourceSystem(nullptr) {}
  ~SourceSystem() override;
  explicit PROTOBUF_CONSTEXPR SourceSystem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SourceSystem(const SourceSystem& from);
  SourceSystem(SourceSystem&& from) noexcept
    : SourceSystem() {
    *this = ::std::move(from);
  }

  inline SourceSystem& operator=(const SourceSystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceSystem& operator=(SourceSystem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SourceSystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const SourceSystem* internal_default_instance() {
    return reinterpret_cast<const SourceSystem*>(
               &_SourceSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SourceSystem& a, SourceSystem& b) {
    a.Swap(&b);
  }
  inline void Swap(SourceSystem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceSystem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SourceSystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SourceSystem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SourceSystem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SourceSystem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceSystem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.SourceSystem";
  }
  protected:
  explicit SourceSystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SourceSystem_SourceType SourceType;
  static constexpr SourceType undefined =
    SourceSystem_SourceType_undefined;
  static constexpr SourceType identity_provider =
    SourceSystem_SourceType_identity_provider;
  static constexpr SourceType source_control_management =
    SourceSystem_SourceType_source_control_management;
  static constexpr SourceType cloud_provider =
    SourceSystem_SourceType_cloud_provider;
  static constexpr SourceType database =
    SourceSystem_SourceType_database;
  static constexpr SourceType network =
    SourceSystem_SourceType_network;
  static constexpr SourceType device_management =
    SourceSystem_SourceType_device_management;
  static constexpr SourceType security_software =
    SourceSystem_SourceType_security_software;
  static constexpr SourceType password_manager =
    SourceSystem_SourceType_password_manager;
  static constexpr SourceType communication =
    SourceSystem_SourceType_communication;
  static constexpr SourceType human_resources =
    SourceSystem_SourceType_human_resources;
  static constexpr SourceType content_management_system =
    SourceSystem_SourceType_content_management_system;
  static constexpr SourceType ticketing =
    SourceSystem_SourceType_ticketing;
  static constexpr SourceType customer_relationship_management =
    SourceSystem_SourceType_customer_relationship_management;
  static constexpr SourceType finance =
    SourceSystem_SourceType_finance;
  static constexpr SourceType analytics =
    SourceSystem_SourceType_analytics;
  static inline bool SourceType_IsValid(int value) {
    return SourceSystem_SourceType_IsValid(value);
  }
  static constexpr SourceType SourceType_MIN =
    SourceSystem_SourceType_SourceType_MIN;
  static constexpr SourceType SourceType_MAX =
    SourceSystem_SourceType_SourceType_MAX;
  static constexpr int SourceType_ARRAYSIZE =
    SourceSystem_SourceType_SourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SourceType_descriptor() {
    return SourceSystem_SourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& SourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SourceType_Name.");
    return SourceSystem_SourceType_Name(enum_t_value);
  }
  static inline bool SourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SourceType* value) {
    return SourceSystem_SourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVendorFieldNumber = 2,
    kUrlFieldNumber = 3,
    kLogoUrlFieldNumber = 4,
    kTypeFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string vendor = 2;
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_NODISCARD std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // string url = 3;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string logo_url = 4;
  void clear_logo_url();
  const std::string& logo_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logo_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logo_url();
  PROTOBUF_NODISCARD std::string* release_logo_url();
  void set_allocated_logo_url(std::string* logo_url);
  private:
  const std::string& _internal_logo_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo_url(const std::string& value);
  std::string* _internal_mutable_logo_url();
  public:

  // .io.openisms.v1.SourceSystem.SourceType type = 5;
  void clear_type();
  ::io::openisms::v1::SourceSystem_SourceType type() const;
  void set_type(::io::openisms::v1::SourceSystem_SourceType value);
  private:
  ::io::openisms::v1::SourceSystem_SourceType _internal_type() const;
  void _internal_set_type(::io::openisms::v1::SourceSystem_SourceType value);
  public:

  // @@protoc_insertion_point(class_scope:io.openisms.v1.SourceSystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_url_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 15,
    kPrivilegesFieldNumber = 16,
    kConnectedAccountsFieldNumber = 21,
    kPossessionsFieldNumber = 22,
    kTagsFieldNumber = 40,
    kPersonFieldNumber = 1,
    kSecondFactorActiveFieldNumber = 5,
    kSecondFactorEnforcedFieldNumber = 6,
    kActiveFieldNumber = 7,
    kSuspendedFieldNumber = 8,
    kDisabledFieldNumber = 9,
    kDeletedFieldNumber = 10,
    kEmploymentFieldNumber = 20,
  };
  // repeated string groups = 15;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  const std::string& groups(int index) const;
  std::string* mutable_groups(int index);
  void set_groups(int index, const std::string& value);
  void set_groups(int index, std::string&& value);
  void set_groups(int index, const char* value);
  void set_groups(int index, const char* value, size_t size);
  std::string* add_groups();
  void add_groups(const std::string& value);
  void add_groups(std::string&& value);
  void add_groups(const char* value);
  void add_groups(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& groups() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_groups();
  private:
  const std::string& _internal_groups(int index) const;
  std::string* _internal_add_groups();
  public:

  // repeated string privileges = 16;
  int privileges_size() const;
  private:
  int _internal_privileges_size() const;
  public:
  void clear_privileges();
  const std::string& privileges(int index) const;
  std::string* mutable_privileges(int index);
  void set_privileges(int index, const std::string& value);
  void set_privileges(int index, std::string&& value);
  void set_privileges(int index, const char* value);
  void set_privileges(int index, const char* value, size_t size);
  std::string* add_privileges();
  void add_privileges(const std::string& value);
  void add_privileges(std::string&& value);
  void add_privileges(const char* value);
  void add_privileges(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& privileges() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_privileges();
  private:
  const std::string& _internal_privileges(int index) const;
  std::string* _internal_add_privileges();
  public:

  // repeated .io.openisms.v1.ConnectedAccount connected_accounts = 21;
  int connected_accounts_size() const;
  private:
  int _internal_connected_accounts_size() const;
  public:
  void clear_connected_accounts();
  ::io::openisms::v1::ConnectedAccount* mutable_connected_accounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::ConnectedAccount >*
      mutable_connected_accounts();
  private:
  const ::io::openisms::v1::ConnectedAccount& _internal_connected_accounts(int index) const;
  ::io::openisms::v1::ConnectedAccount* _internal_add_connected_accounts();
  public:
  const ::io::openisms::v1::ConnectedAccount& connected_accounts(int index) const;
  ::io::openisms::v1::ConnectedAccount* add_connected_accounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::ConnectedAccount >&
      connected_accounts() const;

  // repeated .io.openisms.v1.PhysicalObject possessions = 22;
  int possessions_size() const;
  private:
  int _internal_possessions_size() const;
  public:
  void clear_possessions();
  ::io::openisms::v1::PhysicalObject* mutable_possessions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::PhysicalObject >*
      mutable_possessions();
  private:
  const ::io::openisms::v1::PhysicalObject& _internal_possessions(int index) const;
  ::io::openisms::v1::PhysicalObject* _internal_add_possessions();
  public:
  const ::io::openisms::v1::PhysicalObject& possessions(int index) const;
  ::io::openisms::v1::PhysicalObject* add_possessions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::PhysicalObject >&
      possessions() const;

  // repeated string tags = 40;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // .io.openisms.v1.Person person = 1;
  bool has_person() const;
  private:
  bool _internal_has_person() const;
  public:
  void clear_person();
  const ::io::openisms::v1::Person& person() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::Person* release_person();
  ::io::openisms::v1::Person* mutable_person();
  void set_allocated_person(::io::openisms::v1::Person* person);
  private:
  const ::io::openisms::v1::Person& _internal_person() const;
  ::io::openisms::v1::Person* _internal_mutable_person();
  public:
  void unsafe_arena_set_allocated_person(
      ::io::openisms::v1::Person* person);
  ::io::openisms::v1::Person* unsafe_arena_release_person();

  // .google.protobuf.BoolValue second_factor_active = 5;
  bool has_second_factor_active() const;
  private:
  bool _internal_has_second_factor_active() const;
  public:
  void clear_second_factor_active();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& second_factor_active() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_second_factor_active();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_second_factor_active();
  void set_allocated_second_factor_active(::PROTOBUF_NAMESPACE_ID::BoolValue* second_factor_active);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_second_factor_active() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_second_factor_active();
  public:
  void unsafe_arena_set_allocated_second_factor_active(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* second_factor_active);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_second_factor_active();

  // .google.protobuf.BoolValue second_factor_enforced = 6;
  bool has_second_factor_enforced() const;
  private:
  bool _internal_has_second_factor_enforced() const;
  public:
  void clear_second_factor_enforced();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& second_factor_enforced() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_second_factor_enforced();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_second_factor_enforced();
  void set_allocated_second_factor_enforced(::PROTOBUF_NAMESPACE_ID::BoolValue* second_factor_enforced);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_second_factor_enforced() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_second_factor_enforced();
  public:
  void unsafe_arena_set_allocated_second_factor_enforced(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* second_factor_enforced);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_second_factor_enforced();

  // .google.protobuf.BoolValue active = 7;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& active() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_active();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_active();
  void set_allocated_active(::PROTOBUF_NAMESPACE_ID::BoolValue* active);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_active() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_active();
  public:
  void unsafe_arena_set_allocated_active(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* active);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_active();

  // .google.protobuf.BoolValue suspended = 8;
  bool has_suspended() const;
  private:
  bool _internal_has_suspended() const;
  public:
  void clear_suspended();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& suspended() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_suspended();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_suspended();
  void set_allocated_suspended(::PROTOBUF_NAMESPACE_ID::BoolValue* suspended);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_suspended() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_suspended();
  public:
  void unsafe_arena_set_allocated_suspended(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* suspended);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_suspended();

  // .google.protobuf.BoolValue disabled = 9;
  bool has_disabled() const;
  private:
  bool _internal_has_disabled() const;
  public:
  void clear_disabled();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& disabled() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_disabled();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_disabled();
  void set_allocated_disabled(::PROTOBUF_NAMESPACE_ID::BoolValue* disabled);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_disabled() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_disabled();
  public:
  void unsafe_arena_set_allocated_disabled(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* disabled);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_disabled();

  // .google.protobuf.BoolValue deleted = 10;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& deleted() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_deleted();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_deleted();
  void set_allocated_deleted(::PROTOBUF_NAMESPACE_ID::BoolValue* deleted);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_deleted() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_deleted();
  public:
  void unsafe_arena_set_allocated_deleted(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* deleted);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_deleted();

  // .io.openisms.v1.Employment employment = 20;
  bool has_employment() const;
  private:
  bool _internal_has_employment() const;
  public:
  void clear_employment();
  const ::io::openisms::v1::Employment& employment() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::Employment* release_employment();
  ::io::openisms::v1::Employment* mutable_employment();
  void set_allocated_employment(::io::openisms::v1::Employment* employment);
  private:
  const ::io::openisms::v1::Employment& _internal_employment() const;
  ::io::openisms::v1::Employment* _internal_mutable_employment();
  public:
  void unsafe_arena_set_allocated_employment(
      ::io::openisms::v1::Employment* employment);
  ::io::openisms::v1::Employment* unsafe_arena_release_employment();

  // @@protoc_insertion_point(class_scope:io.openisms.v1.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> groups_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> privileges_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::ConnectedAccount > connected_accounts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::PhysicalObject > possessions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::io::openisms::v1::Person* person_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* second_factor_active_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* second_factor_enforced_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* active_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* suspended_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* disabled_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* deleted_;
  ::io::openisms::v1::Employment* employment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Person final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Person) */ {
 public:
  inline Person() : Person(nullptr) {}
  ~Person() override;
  explicit PROTOBUF_CONSTEXPR Person(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Person(const Person& from);
  Person(Person&& from) noexcept
    : Person() {
    *this = ::std::move(from);
  }

  inline Person& operator=(const Person& from) {
    CopyFrom(from);
    return *this;
  }
  inline Person& operator=(Person&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Person& default_instance() {
    return *internal_default_instance();
  }
  static inline const Person* internal_default_instance() {
    return reinterpret_cast<const Person*>(
               &_Person_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Person& a, Person& b) {
    a.Swap(&b);
  }
  inline void Swap(Person* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Person* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Person* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Person>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Person& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Person& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Person* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Person";
  }
  protected:
  explicit Person(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOtherEmailsFieldNumber = 4,
    kIdFieldNumber = 1,
    kPrimaryEmailFieldNumber = 3,
    kCompanyFieldNumber = 6,
    kNameFieldNumber = 2,
    kPictureFieldNumber = 5,
    kCreatedFieldNumber = 10,
    kUpdatedFieldNumber = 11,
  };
  // repeated string other_emails = 4;
  int other_emails_size() const;
  private:
  int _internal_other_emails_size() const;
  public:
  void clear_other_emails();
  const std::string& other_emails(int index) const;
  std::string* mutable_other_emails(int index);
  void set_other_emails(int index, const std::string& value);
  void set_other_emails(int index, std::string&& value);
  void set_other_emails(int index, const char* value);
  void set_other_emails(int index, const char* value, size_t size);
  std::string* add_other_emails();
  void add_other_emails(const std::string& value);
  void add_other_emails(std::string&& value);
  void add_other_emails(const char* value);
  void add_other_emails(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& other_emails() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_other_emails();
  private:
  const std::string& _internal_other_emails(int index) const;
  std::string* _internal_add_other_emails();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string primary_email = 3;
  void clear_primary_email();
  const std::string& primary_email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_primary_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_primary_email();
  PROTOBUF_NODISCARD std::string* release_primary_email();
  void set_allocated_primary_email(std::string* primary_email);
  private:
  const std::string& _internal_primary_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_email(const std::string& value);
  std::string* _internal_mutable_primary_email();
  public:

  // string company = 6;
  void clear_company();
  const std::string& company() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_company(ArgT0&& arg0, ArgT... args);
  std::string* mutable_company();
  PROTOBUF_NODISCARD std::string* release_company();
  void set_allocated_company(std::string* company);
  private:
  const std::string& _internal_company() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_company(const std::string& value);
  std::string* _internal_mutable_company();
  public:

  // .io.openisms.v1.Name name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::io::openisms::v1::Name& name() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::Name* release_name();
  ::io::openisms::v1::Name* mutable_name();
  void set_allocated_name(::io::openisms::v1::Name* name);
  private:
  const ::io::openisms::v1::Name& _internal_name() const;
  ::io::openisms::v1::Name* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::io::openisms::v1::Name* name);
  ::io::openisms::v1::Name* unsafe_arena_release_name();

  // .io.openisms.v1.Photo picture = 5;
  bool has_picture() const;
  private:
  bool _internal_has_picture() const;
  public:
  void clear_picture();
  const ::io::openisms::v1::Photo& picture() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::Photo* release_picture();
  ::io::openisms::v1::Photo* mutable_picture();
  void set_allocated_picture(::io::openisms::v1::Photo* picture);
  private:
  const ::io::openisms::v1::Photo& _internal_picture() const;
  ::io::openisms::v1::Photo* _internal_mutable_picture();
  public:
  void unsafe_arena_set_allocated_picture(
      ::io::openisms::v1::Photo* picture);
  ::io::openisms::v1::Photo* unsafe_arena_release_picture();

  // .google.protobuf.Timestamp created = 10;
  bool has_created() const;
  private:
  bool _internal_has_created() const;
  public:
  void clear_created();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created();
  void set_allocated_created(::PROTOBUF_NAMESPACE_ID::Timestamp* created);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created();
  public:
  void unsafe_arena_set_allocated_created(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created();

  // .google.protobuf.Timestamp updated = 11;
  bool has_updated() const;
  private:
  bool _internal_has_updated() const;
  public:
  void clear_updated();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated();
  void set_allocated_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* updated);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated();
  public:
  void unsafe_arena_set_allocated_updated(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated();

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Person)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> other_emails_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr primary_email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr company_;
  ::io::openisms::v1::Name* name_;
  ::io::openisms::v1::Photo* picture_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Name final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Name) */ {
 public:
  inline Name() : Name(nullptr) {}
  ~Name() override;
  explicit PROTOBUF_CONSTEXPR Name(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Name(const Name& from);
  Name(Name&& from) noexcept
    : Name() {
    *this = ::std::move(from);
  }

  inline Name& operator=(const Name& from) {
    CopyFrom(from);
    return *this;
  }
  inline Name& operator=(Name&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Name& default_instance() {
    return *internal_default_instance();
  }
  static inline const Name* internal_default_instance() {
    return reinterpret_cast<const Name*>(
               &_Name_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Name& a, Name& b) {
    a.Swap(&b);
  }
  inline void Swap(Name* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Name* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Name* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Name>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Name& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Name& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Name* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Name";
  }
  protected:
  explicit Name(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGivenNameFieldNumber = 1,
    kFamilyNameFieldNumber = 2,
    kFullNameFieldNumber = 3,
    kTitleFieldNumber = 4,
    kPositionFieldNumber = 5,
    kRoleFieldNumber = 6,
  };
  // string given_name = 1;
  void clear_given_name();
  const std::string& given_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_given_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_given_name();
  PROTOBUF_NODISCARD std::string* release_given_name();
  void set_allocated_given_name(std::string* given_name);
  private:
  const std::string& _internal_given_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_given_name(const std::string& value);
  std::string* _internal_mutable_given_name();
  public:

  // string family_name = 2;
  void clear_family_name();
  const std::string& family_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_family_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_family_name();
  PROTOBUF_NODISCARD std::string* release_family_name();
  void set_allocated_family_name(std::string* family_name);
  private:
  const std::string& _internal_family_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_family_name(const std::string& value);
  std::string* _internal_mutable_family_name();
  public:

  // string full_name = 3;
  void clear_full_name();
  const std::string& full_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_name();
  PROTOBUF_NODISCARD std::string* release_full_name();
  void set_allocated_full_name(std::string* full_name);
  private:
  const std::string& _internal_full_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_name(const std::string& value);
  std::string* _internal_mutable_full_name();
  public:

  // string title = 4;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string position = 5;
  void clear_position();
  const std::string& position() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_position(ArgT0&& arg0, ArgT... args);
  std::string* mutable_position();
  PROTOBUF_NODISCARD std::string* release_position();
  void set_allocated_position(std::string* position);
  private:
  const std::string& _internal_position() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_position(const std::string& value);
  std::string* _internal_mutable_position();
  public:

  // string role = 6;
  void clear_role();
  const std::string& role() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* role);
  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(const std::string& value);
  std::string* _internal_mutable_role();
  public:

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Name)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr given_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr position_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Photo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Photo) */ {
 public:
  inline Photo() : Photo(nullptr) {}
  ~Photo() override;
  explicit PROTOBUF_CONSTEXPR Photo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Photo(const Photo& from);
  Photo(Photo&& from) noexcept
    : Photo() {
    *this = ::std::move(from);
  }

  inline Photo& operator=(const Photo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Photo& operator=(Photo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Photo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Photo* internal_default_instance() {
    return reinterpret_cast<const Photo*>(
               &_Photo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Photo& a, Photo& b) {
    a.Swap(&b);
  }
  inline void Swap(Photo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Photo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Photo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Photo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Photo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Photo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Photo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Photo";
  }
  protected:
  explicit Photo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kBase64EncodedFieldNumber = 2,
    kMimeTypeFieldNumber = 3,
    kEtagFieldNumber = 4,
    kLastModifiedFieldNumber = 5,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string base_64_encoded = 2;
  void clear_base_64_encoded();
  const std::string& base_64_encoded() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_64_encoded(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_64_encoded();
  PROTOBUF_NODISCARD std::string* release_base_64_encoded();
  void set_allocated_base_64_encoded(std::string* base_64_encoded);
  private:
  const std::string& _internal_base_64_encoded() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_64_encoded(const std::string& value);
  std::string* _internal_mutable_base_64_encoded();
  public:

  // string mime_type = 3;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // string etag = 4;
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // .google.protobuf.Timestamp last_modified = 5;
  bool has_last_modified() const;
  private:
  bool _internal_has_last_modified() const;
  public:
  void clear_last_modified();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_modified() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_modified();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_modified();
  void set_allocated_last_modified(::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_modified() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_modified();
  public:
  void unsafe_arena_set_allocated_last_modified(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_modified();

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Photo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_64_encoded_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Employment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Employment) */ {
 public:
  inline Employment() : Employment(nullptr) {}
  ~Employment() override;
  explicit PROTOBUF_CONSTEXPR Employment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Employment(const Employment& from);
  Employment(Employment&& from) noexcept
    : Employment() {
    *this = ::std::move(from);
  }

  inline Employment& operator=(const Employment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Employment& operator=(Employment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Employment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Employment* internal_default_instance() {
    return reinterpret_cast<const Employment*>(
               &_Employment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Employment& a, Employment& b) {
    a.Swap(&b);
  }
  inline void Swap(Employment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Employment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Employment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Employment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Employment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Employment& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Employment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Employment";
  }
  protected:
  explicit Employment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractFieldNumber = 1,
    kStatusFieldNumber = 2,
    kBeginFieldNumber = 3,
    kEndFieldNumber = 4,
  };
  // string contract = 1;
  void clear_contract();
  const std::string& contract() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract();
  PROTOBUF_NODISCARD std::string* release_contract();
  void set_allocated_contract(std::string* contract);
  private:
  const std::string& _internal_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract(const std::string& value);
  std::string* _internal_mutable_contract();
  public:

  // string status = 2;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .io.openisms.v1.Date begin = 3;
  bool has_begin() const;
  private:
  bool _internal_has_begin() const;
  public:
  void clear_begin();
  const ::io::openisms::v1::Date& begin() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::Date* release_begin();
  ::io::openisms::v1::Date* mutable_begin();
  void set_allocated_begin(::io::openisms::v1::Date* begin);
  private:
  const ::io::openisms::v1::Date& _internal_begin() const;
  ::io::openisms::v1::Date* _internal_mutable_begin();
  public:
  void unsafe_arena_set_allocated_begin(
      ::io::openisms::v1::Date* begin);
  ::io::openisms::v1::Date* unsafe_arena_release_begin();

  // .io.openisms.v1.Date end = 4;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::io::openisms::v1::Date& end() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::Date* release_end();
  ::io::openisms::v1::Date* mutable_end();
  void set_allocated_end(::io::openisms::v1::Date* end);
  private:
  const ::io::openisms::v1::Date& _internal_end() const;
  ::io::openisms::v1::Date* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::io::openisms::v1::Date* end);
  ::io::openisms::v1::Date* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Employment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::io::openisms::v1::Date* begin_;
  ::io::openisms::v1::Date* end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ConnectedAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.ConnectedAccount) */ {
 public:
  inline ConnectedAccount() : ConnectedAccount(nullptr) {}
  ~ConnectedAccount() override;
  explicit PROTOBUF_CONSTEXPR ConnectedAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectedAccount(const ConnectedAccount& from);
  ConnectedAccount(ConnectedAccount&& from) noexcept
    : ConnectedAccount() {
    *this = ::std::move(from);
  }

  inline ConnectedAccount& operator=(const ConnectedAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectedAccount& operator=(ConnectedAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectedAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectedAccount* internal_default_instance() {
    return reinterpret_cast<const ConnectedAccount*>(
               &_ConnectedAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ConnectedAccount& a, ConnectedAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectedAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectedAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectedAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectedAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectedAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConnectedAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectedAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.ConnectedAccount";
  }
  protected:
  explicit ConnectedAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScopesFieldNumber = 6,
    kAppIdFieldNumber = 1,
    kAppNameFieldNumber = 2,
    kAppTypeFieldNumber = 3,
    kAppUrlFieldNumber = 4,
    kUserIdFieldNumber = 5,
  };
  // repeated string scopes = 6;
  int scopes_size() const;
  private:
  int _internal_scopes_size() const;
  public:
  void clear_scopes();
  const std::string& scopes(int index) const;
  std::string* mutable_scopes(int index);
  void set_scopes(int index, const std::string& value);
  void set_scopes(int index, std::string&& value);
  void set_scopes(int index, const char* value);
  void set_scopes(int index, const char* value, size_t size);
  std::string* add_scopes();
  void add_scopes(const std::string& value);
  void add_scopes(std::string&& value);
  void add_scopes(const char* value);
  void add_scopes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& scopes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_scopes();
  private:
  const std::string& _internal_scopes(int index) const;
  std::string* _internal_add_scopes();
  public:

  // string app_id = 1;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string app_name = 2;
  void clear_app_name();
  const std::string& app_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* app_name);
  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(const std::string& value);
  std::string* _internal_mutable_app_name();
  public:

  // string app_type = 3;
  void clear_app_type();
  const std::string& app_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_type();
  PROTOBUF_NODISCARD std::string* release_app_type();
  void set_allocated_app_type(std::string* app_type);
  private:
  const std::string& _internal_app_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_type(const std::string& value);
  std::string* _internal_mutable_app_type();
  public:

  // string app_url = 4;
  void clear_app_url();
  const std::string& app_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_url();
  PROTOBUF_NODISCARD std::string* release_app_url();
  void set_allocated_app_url(std::string* app_url);
  private:
  const std::string& _internal_app_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_url(const std::string& value);
  std::string* _internal_mutable_app_url();
  public:

  // string user_id = 5;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:io.openisms.v1.ConnectedAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> scopes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PhysicalObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.PhysicalObject) */ {
 public:
  inline PhysicalObject() : PhysicalObject(nullptr) {}
  ~PhysicalObject() override;
  explicit PROTOBUF_CONSTEXPR PhysicalObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhysicalObject(const PhysicalObject& from);
  PhysicalObject(PhysicalObject&& from) noexcept
    : PhysicalObject() {
    *this = ::std::move(from);
  }

  inline PhysicalObject& operator=(const PhysicalObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhysicalObject& operator=(PhysicalObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhysicalObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhysicalObject* internal_default_instance() {
    return reinterpret_cast<const PhysicalObject*>(
               &_PhysicalObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PhysicalObject& a, PhysicalObject& b) {
    a.Swap(&b);
  }
  inline void Swap(PhysicalObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhysicalObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhysicalObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhysicalObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhysicalObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PhysicalObject& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicalObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.PhysicalObject";
  }
  protected:
  explicit PhysicalObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworksFieldNumber = 9,
    kUserAccountsFieldNumber = 11,
    kProfilesFieldNumber = 14,
    kAppsFieldNumber = 15,
    kTagsFieldNumber = 20,
    kTypeFieldNumber = 1,
    kNameFieldNumber = 2,
    kManufacturerFieldNumber = 3,
    kVendorFieldNumber = 4,
    kIdentifierFieldNumber = 5,
    kSerialNumberFieldNumber = 6,
    kImeiFieldNumber = 7,
    kMeidFieldNumber = 8,
    kHostnameFieldNumber = 10,
    kOsFieldNumber = 12,
    kSecurityFieldNumber = 13,
  };
  // repeated .io.openisms.v1.Network networks = 9;
  int networks_size() const;
  private:
  int _internal_networks_size() const;
  public:
  void clear_networks();
  ::io::openisms::v1::Network* mutable_networks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Network >*
      mutable_networks();
  private:
  const ::io::openisms::v1::Network& _internal_networks(int index) const;
  ::io::openisms::v1::Network* _internal_add_networks();
  public:
  const ::io::openisms::v1::Network& networks(int index) const;
  ::io::openisms::v1::Network* add_networks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Network >&
      networks() const;

  // repeated string user_accounts = 11;
  int user_accounts_size() const;
  private:
  int _internal_user_accounts_size() const;
  public:
  void clear_user_accounts();
  const std::string& user_accounts(int index) const;
  std::string* mutable_user_accounts(int index);
  void set_user_accounts(int index, const std::string& value);
  void set_user_accounts(int index, std::string&& value);
  void set_user_accounts(int index, const char* value);
  void set_user_accounts(int index, const char* value, size_t size);
  std::string* add_user_accounts();
  void add_user_accounts(const std::string& value);
  void add_user_accounts(std::string&& value);
  void add_user_accounts(const char* value);
  void add_user_accounts(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_accounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_accounts();
  private:
  const std::string& _internal_user_accounts(int index) const;
  std::string* _internal_add_user_accounts();
  public:

  // repeated .io.openisms.v1.Profile profiles = 14;
  int profiles_size() const;
  private:
  int _internal_profiles_size() const;
  public:
  void clear_profiles();
  ::io::openisms::v1::Profile* mutable_profiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Profile >*
      mutable_profiles();
  private:
  const ::io::openisms::v1::Profile& _internal_profiles(int index) const;
  ::io::openisms::v1::Profile* _internal_add_profiles();
  public:
  const ::io::openisms::v1::Profile& profiles(int index) const;
  ::io::openisms::v1::Profile* add_profiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Profile >&
      profiles() const;

  // repeated .io.openisms.v1.Application apps = 15;
  int apps_size() const;
  private:
  int _internal_apps_size() const;
  public:
  void clear_apps();
  ::io::openisms::v1::Application* mutable_apps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Application >*
      mutable_apps();
  private:
  const ::io::openisms::v1::Application& _internal_apps(int index) const;
  ::io::openisms::v1::Application* _internal_add_apps();
  public:
  const ::io::openisms::v1::Application& apps(int index) const;
  ::io::openisms::v1::Application* add_apps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Application >&
      apps() const;

  // repeated string tags = 20;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string manufacturer = 3;
  void clear_manufacturer();
  const std::string& manufacturer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacturer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacturer();
  PROTOBUF_NODISCARD std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);
  private:
  const std::string& _internal_manufacturer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer(const std::string& value);
  std::string* _internal_mutable_manufacturer();
  public:

  // string vendor = 4;
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_NODISCARD std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // string identifier = 5;
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // string serial_number = 6;
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // string imei = 7;
  void clear_imei();
  const std::string& imei() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imei(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imei();
  PROTOBUF_NODISCARD std::string* release_imei();
  void set_allocated_imei(std::string* imei);
  private:
  const std::string& _internal_imei() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imei(const std::string& value);
  std::string* _internal_mutable_imei();
  public:

  // string meid = 8;
  void clear_meid();
  const std::string& meid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_meid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_meid();
  PROTOBUF_NODISCARD std::string* release_meid();
  void set_allocated_meid(std::string* meid);
  private:
  const std::string& _internal_meid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_meid(const std::string& value);
  std::string* _internal_mutable_meid();
  public:

  // string hostname = 10;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // .io.openisms.v1.OperatingSystem os = 12;
  bool has_os() const;
  private:
  bool _internal_has_os() const;
  public:
  void clear_os();
  const ::io::openisms::v1::OperatingSystem& os() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::OperatingSystem* release_os();
  ::io::openisms::v1::OperatingSystem* mutable_os();
  void set_allocated_os(::io::openisms::v1::OperatingSystem* os);
  private:
  const ::io::openisms::v1::OperatingSystem& _internal_os() const;
  ::io::openisms::v1::OperatingSystem* _internal_mutable_os();
  public:
  void unsafe_arena_set_allocated_os(
      ::io::openisms::v1::OperatingSystem* os);
  ::io::openisms::v1::OperatingSystem* unsafe_arena_release_os();

  // .io.openisms.v1.SecurityFeatures security = 13;
  bool has_security() const;
  private:
  bool _internal_has_security() const;
  public:
  void clear_security();
  const ::io::openisms::v1::SecurityFeatures& security() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::SecurityFeatures* release_security();
  ::io::openisms::v1::SecurityFeatures* mutable_security();
  void set_allocated_security(::io::openisms::v1::SecurityFeatures* security);
  private:
  const ::io::openisms::v1::SecurityFeatures& _internal_security() const;
  ::io::openisms::v1::SecurityFeatures* _internal_mutable_security();
  public:
  void unsafe_arena_set_allocated_security(
      ::io::openisms::v1::SecurityFeatures* security);
  ::io::openisms::v1::SecurityFeatures* unsafe_arena_release_security();

  // @@protoc_insertion_point(class_scope:io.openisms.v1.PhysicalObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Network > networks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_accounts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Profile > profiles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Application > apps_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imei_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  ::io::openisms::v1::OperatingSystem* os_;
  ::io::openisms::v1::SecurityFeatures* security_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class SecurityFeatures final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.SecurityFeatures) */ {
 public:
  inline SecurityFeatures() : SecurityFeatures(nullptr) {}
  ~SecurityFeatures() override;
  explicit PROTOBUF_CONSTEXPR SecurityFeatures(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecurityFeatures(const SecurityFeatures& from);
  SecurityFeatures(SecurityFeatures&& from) noexcept
    : SecurityFeatures() {
    *this = ::std::move(from);
  }

  inline SecurityFeatures& operator=(const SecurityFeatures& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityFeatures& operator=(SecurityFeatures&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecurityFeatures& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecurityFeatures* internal_default_instance() {
    return reinterpret_cast<const SecurityFeatures*>(
               &_SecurityFeatures_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SecurityFeatures& a, SecurityFeatures& b) {
    a.Swap(&b);
  }
  inline void Swap(SecurityFeatures* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecurityFeatures* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecurityFeatures* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecurityFeatures>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecurityFeatures& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SecurityFeatures& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityFeatures* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.SecurityFeatures";
  }
  protected:
  explicit SecurityFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActivationLockFieldNumber = 1,
    kSupervisedFieldNumber = 2,
    kFileVaultFieldNumber = 3,
    kFullDiskEncryptionFieldNumber = 4,
    kSecurePasswordFieldNumber = 5,
    kAutomaticScreenLockFieldNumber = 6,
    kScreenLockAfterFieldNumber = 7,
    kFirewallEnabledFieldNumber = 8,
    kAutomaticUpdatesFieldNumber = 9,
  };
  // .google.protobuf.BoolValue activation_lock = 1;
  bool has_activation_lock() const;
  private:
  bool _internal_has_activation_lock() const;
  public:
  void clear_activation_lock();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& activation_lock() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_activation_lock();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_activation_lock();
  void set_allocated_activation_lock(::PROTOBUF_NAMESPACE_ID::BoolValue* activation_lock);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_activation_lock() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_activation_lock();
  public:
  void unsafe_arena_set_allocated_activation_lock(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* activation_lock);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_activation_lock();

  // .google.protobuf.BoolValue supervised = 2;
  bool has_supervised() const;
  private:
  bool _internal_has_supervised() const;
  public:
  void clear_supervised();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& supervised() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_supervised();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_supervised();
  void set_allocated_supervised(::PROTOBUF_NAMESPACE_ID::BoolValue* supervised);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_supervised() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_supervised();
  public:
  void unsafe_arena_set_allocated_supervised(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* supervised);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_supervised();

  // .google.protobuf.BoolValue file_vault = 3;
  bool has_file_vault() const;
  private:
  bool _internal_has_file_vault() const;
  public:
  void clear_file_vault();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& file_vault() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_file_vault();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_file_vault();
  void set_allocated_file_vault(::PROTOBUF_NAMESPACE_ID::BoolValue* file_vault);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_file_vault() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_file_vault();
  public:
  void unsafe_arena_set_allocated_file_vault(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* file_vault);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_file_vault();

  // .google.protobuf.BoolValue full_disk_encryption = 4;
  bool has_full_disk_encryption() const;
  private:
  bool _internal_has_full_disk_encryption() const;
  public:
  void clear_full_disk_encryption();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& full_disk_encryption() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_full_disk_encryption();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_full_disk_encryption();
  void set_allocated_full_disk_encryption(::PROTOBUF_NAMESPACE_ID::BoolValue* full_disk_encryption);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_full_disk_encryption() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_full_disk_encryption();
  public:
  void unsafe_arena_set_allocated_full_disk_encryption(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* full_disk_encryption);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_full_disk_encryption();

  // .google.protobuf.BoolValue secure_password = 5;
  bool has_secure_password() const;
  private:
  bool _internal_has_secure_password() const;
  public:
  void clear_secure_password();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& secure_password() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_secure_password();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_secure_password();
  void set_allocated_secure_password(::PROTOBUF_NAMESPACE_ID::BoolValue* secure_password);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_secure_password() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_secure_password();
  public:
  void unsafe_arena_set_allocated_secure_password(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* secure_password);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_secure_password();

  // .google.protobuf.BoolValue automatic_screen_lock = 6;
  bool has_automatic_screen_lock() const;
  private:
  bool _internal_has_automatic_screen_lock() const;
  public:
  void clear_automatic_screen_lock();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& automatic_screen_lock() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_automatic_screen_lock();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_automatic_screen_lock();
  void set_allocated_automatic_screen_lock(::PROTOBUF_NAMESPACE_ID::BoolValue* automatic_screen_lock);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_automatic_screen_lock() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_automatic_screen_lock();
  public:
  void unsafe_arena_set_allocated_automatic_screen_lock(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* automatic_screen_lock);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_automatic_screen_lock();

  // .google.protobuf.Int32Value screen_lock_after = 7;
  bool has_screen_lock_after() const;
  private:
  bool _internal_has_screen_lock_after() const;
  public:
  void clear_screen_lock_after();
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& screen_lock_after() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Int32Value* release_screen_lock_after();
  ::PROTOBUF_NAMESPACE_ID::Int32Value* mutable_screen_lock_after();
  void set_allocated_screen_lock_after(::PROTOBUF_NAMESPACE_ID::Int32Value* screen_lock_after);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& _internal_screen_lock_after() const;
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _internal_mutable_screen_lock_after();
  public:
  void unsafe_arena_set_allocated_screen_lock_after(
      ::PROTOBUF_NAMESPACE_ID::Int32Value* screen_lock_after);
  ::PROTOBUF_NAMESPACE_ID::Int32Value* unsafe_arena_release_screen_lock_after();

  // .google.protobuf.BoolValue firewall_enabled = 8;
  bool has_firewall_enabled() const;
  private:
  bool _internal_has_firewall_enabled() const;
  public:
  void clear_firewall_enabled();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& firewall_enabled() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_firewall_enabled();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_firewall_enabled();
  void set_allocated_firewall_enabled(::PROTOBUF_NAMESPACE_ID::BoolValue* firewall_enabled);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_firewall_enabled() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_firewall_enabled();
  public:
  void unsafe_arena_set_allocated_firewall_enabled(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* firewall_enabled);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_firewall_enabled();

  // .google.protobuf.BoolValue automatic_updates = 9;
  bool has_automatic_updates() const;
  private:
  bool _internal_has_automatic_updates() const;
  public:
  void clear_automatic_updates();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& automatic_updates() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_automatic_updates();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_automatic_updates();
  void set_allocated_automatic_updates(::PROTOBUF_NAMESPACE_ID::BoolValue* automatic_updates);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_automatic_updates() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_automatic_updates();
  public:
  void unsafe_arena_set_allocated_automatic_updates(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* automatic_updates);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_automatic_updates();

  // @@protoc_insertion_point(class_scope:io.openisms.v1.SecurityFeatures)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* activation_lock_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* supervised_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* file_vault_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* full_disk_encryption_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* secure_password_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* automatic_screen_lock_;
  ::PROTOBUF_NAMESPACE_ID::Int32Value* screen_lock_after_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* firewall_enabled_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* automatic_updates_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Network final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Network) */ {
 public:
  inline Network() : Network(nullptr) {}
  ~Network() override;
  explicit PROTOBUF_CONSTEXPR Network(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Network(const Network& from);
  Network(Network&& from) noexcept
    : Network() {
    *this = ::std::move(from);
  }

  inline Network& operator=(const Network& from) {
    CopyFrom(from);
    return *this;
  }
  inline Network& operator=(Network&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Network& default_instance() {
    return *internal_default_instance();
  }
  static inline const Network* internal_default_instance() {
    return reinterpret_cast<const Network*>(
               &_Network_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Network& a, Network& b) {
    a.Swap(&b);
  }
  inline void Swap(Network* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Network* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Network* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Network>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Network& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Network& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Network* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Network";
  }
  protected:
  explicit Network(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kMacAddressFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string mac_address = 3;
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Network)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class OperatingSystem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.OperatingSystem) */ {
 public:
  inline OperatingSystem() : OperatingSystem(nullptr) {}
  ~OperatingSystem() override;
  explicit PROTOBUF_CONSTEXPR OperatingSystem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperatingSystem(const OperatingSystem& from);
  OperatingSystem(OperatingSystem&& from) noexcept
    : OperatingSystem() {
    *this = ::std::move(from);
  }

  inline OperatingSystem& operator=(const OperatingSystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperatingSystem& operator=(OperatingSystem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperatingSystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperatingSystem* internal_default_instance() {
    return reinterpret_cast<const OperatingSystem*>(
               &_OperatingSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(OperatingSystem& a, OperatingSystem& b) {
    a.Swap(&b);
  }
  inline void Swap(OperatingSystem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperatingSystem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperatingSystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperatingSystem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperatingSystem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OperatingSystem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperatingSystem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.OperatingSystem";
  }
  protected:
  explicit OperatingSystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OperatingSystem_OperatingSystems OperatingSystems;
  static constexpr OperatingSystems undefined =
    OperatingSystem_OperatingSystems_undefined;
  static constexpr OperatingSystems macos =
    OperatingSystem_OperatingSystems_macos;
  static constexpr OperatingSystems windows =
    OperatingSystem_OperatingSystems_windows;
  static constexpr OperatingSystems linux =
    OperatingSystem_OperatingSystems_linux;
  static constexpr OperatingSystems unix =
    OperatingSystem_OperatingSystems_unix;
  static constexpr OperatingSystems chrome_os =
    OperatingSystem_OperatingSystems_chrome_os;
  static constexpr OperatingSystems ios =
    OperatingSystem_OperatingSystems_ios;
  static constexpr OperatingSystems android =
    OperatingSystem_OperatingSystems_android;
  static constexpr OperatingSystems ros =
    OperatingSystem_OperatingSystems_ros;
  static constexpr OperatingSystems other =
    OperatingSystem_OperatingSystems_other;
  static inline bool OperatingSystems_IsValid(int value) {
    return OperatingSystem_OperatingSystems_IsValid(value);
  }
  static constexpr OperatingSystems OperatingSystems_MIN =
    OperatingSystem_OperatingSystems_OperatingSystems_MIN;
  static constexpr OperatingSystems OperatingSystems_MAX =
    OperatingSystem_OperatingSystems_OperatingSystems_MAX;
  static constexpr int OperatingSystems_ARRAYSIZE =
    OperatingSystem_OperatingSystems_OperatingSystems_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OperatingSystems_descriptor() {
    return OperatingSystem_OperatingSystems_descriptor();
  }
  template<typename T>
  static inline const std::string& OperatingSystems_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OperatingSystems>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OperatingSystems_Name.");
    return OperatingSystem_OperatingSystems_Name(enum_t_value);
  }
  static inline bool OperatingSystems_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OperatingSystems* value) {
    return OperatingSystem_OperatingSystems_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMajorVersionFieldNumber = 2,
    kFullVersionFieldNumber = 3,
    kOsFieldNumber = 1,
  };
  // string major_version = 2;
  void clear_major_version();
  const std::string& major_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_major_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_major_version();
  PROTOBUF_NODISCARD std::string* release_major_version();
  void set_allocated_major_version(std::string* major_version);
  private:
  const std::string& _internal_major_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_major_version(const std::string& value);
  std::string* _internal_mutable_major_version();
  public:

  // string full_version = 3;
  void clear_full_version();
  const std::string& full_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_version();
  PROTOBUF_NODISCARD std::string* release_full_version();
  void set_allocated_full_version(std::string* full_version);
  private:
  const std::string& _internal_full_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_version(const std::string& value);
  std::string* _internal_mutable_full_version();
  public:

  // .io.openisms.v1.OperatingSystem.OperatingSystems os = 1;
  void clear_os();
  ::io::openisms::v1::OperatingSystem_OperatingSystems os() const;
  void set_os(::io::openisms::v1::OperatingSystem_OperatingSystems value);
  private:
  ::io::openisms::v1::OperatingSystem_OperatingSystems _internal_os() const;
  void _internal_set_os(::io::openisms::v1::OperatingSystem_OperatingSystems value);
  public:

  // @@protoc_insertion_point(class_scope:io.openisms.v1.OperatingSystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr major_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_version_;
  int os_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Application final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Application) */ {
 public:
  inline Application() : Application(nullptr) {}
  ~Application() override;
  explicit PROTOBUF_CONSTEXPR Application(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Application(const Application& from);
  Application(Application&& from) noexcept
    : Application() {
    *this = ::std::move(from);
  }

  inline Application& operator=(const Application& from) {
    CopyFrom(from);
    return *this;
  }
  inline Application& operator=(Application&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Application& default_instance() {
    return *internal_default_instance();
  }
  static inline const Application* internal_default_instance() {
    return reinterpret_cast<const Application*>(
               &_Application_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Application& a, Application& b) {
    a.Swap(&b);
  }
  inline void Swap(Application* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Application* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Application* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Application>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Application& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Application& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Application* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Application";
  }
  protected:
  explicit Application(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPathFieldNumber = 2,
    kVendorFieldNumber = 3,
    kUrlFieldNumber = 4,
    kDescriptionFieldNumber = 5,
    kVersionFieldNumber = 6,
    kInstallationSourceFieldNumber = 9,
    kSignedFieldNumber = 7,
    kSystemAppFieldNumber = 8,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string vendor = 3;
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_NODISCARD std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // string url = 4;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string description = 5;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string version = 6;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string installation_source = 9;
  void clear_installation_source();
  const std::string& installation_source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_installation_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_installation_source();
  PROTOBUF_NODISCARD std::string* release_installation_source();
  void set_allocated_installation_source(std::string* installation_source);
  private:
  const std::string& _internal_installation_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_installation_source(const std::string& value);
  std::string* _internal_mutable_installation_source();
  public:

  // .google.protobuf.BoolValue signed = 7;
  bool has_signed_() const;
  private:
  bool _internal_has_signed_() const;
  public:
  void clear_signed_();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& signed_() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_signed_();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_signed_();
  void set_allocated_signed_(::PROTOBUF_NAMESPACE_ID::BoolValue* signed_);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_signed_() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_signed_();
  public:
  void unsafe_arena_set_allocated_signed_(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* signed_);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_signed_();

  // .google.protobuf.BoolValue system_app = 8;
  bool has_system_app() const;
  private:
  bool _internal_has_system_app() const;
  public:
  void clear_system_app();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& system_app() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_system_app();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_system_app();
  void set_allocated_system_app(::PROTOBUF_NAMESPACE_ID::BoolValue* system_app);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_system_app() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_system_app();
  public:
  void unsafe_arena_set_allocated_system_app(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* system_app);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_system_app();

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Application)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr installation_source_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* signed__;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* system_app_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Profile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Profile) */ {
 public:
  inline Profile() : Profile(nullptr) {}
  ~Profile() override;
  explicit PROTOBUF_CONSTEXPR Profile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Profile(const Profile& from);
  Profile(Profile&& from) noexcept
    : Profile() {
    *this = ::std::move(from);
  }

  inline Profile& operator=(const Profile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile& operator=(Profile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile* internal_default_instance() {
    return reinterpret_cast<const Profile*>(
               &_Profile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Profile& a, Profile& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Profile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Profile& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Profile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Profile";
  }
  protected:
  explicit Profile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIdentifierFieldNumber = 2,
    kPayloadTypeFieldNumber = 4,
    kPayloadIdentifierFieldNumber = 5,
    kRemovalAllowedFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string identifier = 2;
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // string payload_type = 4;
  void clear_payload_type();
  const std::string& payload_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload_type();
  PROTOBUF_NODISCARD std::string* release_payload_type();
  void set_allocated_payload_type(std::string* payload_type);
  private:
  const std::string& _internal_payload_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload_type(const std::string& value);
  std::string* _internal_mutable_payload_type();
  public:

  // string payload_identifier = 5;
  void clear_payload_identifier();
  const std::string& payload_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload_identifier();
  PROTOBUF_NODISCARD std::string* release_payload_identifier();
  void set_allocated_payload_identifier(std::string* payload_identifier);
  private:
  const std::string& _internal_payload_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload_identifier(const std::string& value);
  std::string* _internal_mutable_payload_identifier();
  public:

  // .google.protobuf.BoolValue removal_allowed = 3;
  bool has_removal_allowed() const;
  private:
  bool _internal_has_removal_allowed() const;
  public:
  void clear_removal_allowed();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& removal_allowed() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_removal_allowed();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_removal_allowed();
  void set_allocated_removal_allowed(::PROTOBUF_NAMESPACE_ID::BoolValue* removal_allowed);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_removal_allowed() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_removal_allowed();
  public:
  void unsafe_arena_set_allocated_removal_allowed(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* removal_allowed);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_removal_allowed();

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Profile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_identifier_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* removal_allowed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Date final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Date) */ {
 public:
  inline Date() : Date(nullptr) {}
  ~Date() override;
  explicit PROTOBUF_CONSTEXPR Date(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Date(const Date& from);
  Date(Date&& from) noexcept
    : Date() {
    *this = ::std::move(from);
  }

  inline Date& operator=(const Date& from) {
    CopyFrom(from);
    return *this;
  }
  inline Date& operator=(Date&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Date& default_instance() {
    return *internal_default_instance();
  }
  static inline const Date* internal_default_instance() {
    return reinterpret_cast<const Date*>(
               &_Date_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Date& a, Date& b) {
    a.Swap(&b);
  }
  inline void Swap(Date* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Date* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Date* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Date>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Date& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Date& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Date* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Date";
  }
  protected:
  explicit Date(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYearFieldNumber = 1,
    kMonthFieldNumber = 2,
    kDayFieldNumber = 3,
  };
  // int32 year = 1;
  void clear_year();
  int32_t year() const;
  void set_year(int32_t value);
  private:
  int32_t _internal_year() const;
  void _internal_set_year(int32_t value);
  public:

  // int32 month = 2;
  void clear_month();
  int32_t month() const;
  void set_month(int32_t value);
  private:
  int32_t _internal_month() const;
  void _internal_set_month(int32_t value);
  public:

  // int32 day = 3;
  void clear_day();
  int32_t day() const;
  void set_day(int32_t value);
  private:
  int32_t _internal_day() const;
  void _internal_set_day(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Date)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t year_;
  int32_t month_;
  int32_t day_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Certification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Certification) */ {
 public:
  inline Certification() : Certification(nullptr) {}
  ~Certification() override;
  explicit PROTOBUF_CONSTEXPR Certification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Certification(const Certification& from);
  Certification(Certification&& from) noexcept
    : Certification() {
    *this = ::std::move(from);
  }

  inline Certification& operator=(const Certification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Certification& operator=(Certification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Certification& default_instance() {
    return *internal_default_instance();
  }
  static inline const Certification* internal_default_instance() {
    return reinterpret_cast<const Certification*>(
               &_Certification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Certification& a, Certification& b) {
    a.Swap(&b);
  }
  inline void Swap(Certification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Certification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Certification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Certification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Certification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Certification& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Certification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Certification";
  }
  protected:
  explicit Certification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 10,
    kTypeFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // repeated string tags = 10;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Certification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Company final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Company) */ {
 public:
  inline Company() : Company(nullptr) {}
  ~Company() override;
  explicit PROTOBUF_CONSTEXPR Company(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Company(const Company& from);
  Company(Company&& from) noexcept
    : Company() {
    *this = ::std::move(from);
  }

  inline Company& operator=(const Company& from) {
    CopyFrom(from);
    return *this;
  }
  inline Company& operator=(Company&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Company& default_instance() {
    return *internal_default_instance();
  }
  static inline const Company* internal_default_instance() {
    return reinterpret_cast<const Company*>(
               &_Company_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Company& a, Company& b) {
    a.Swap(&b);
  }
  inline void Swap(Company* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Company* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Company* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Company>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Company& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Company& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Company* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Company";
  }
  protected:
  explicit Company(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 5,
    kNameFieldNumber = 1,
    kUrlFieldNumber = 2,
    kCategoryFieldNumber = 3,
    kContactFieldNumber = 4,
  };
  // repeated string address = 5;
  int address_size() const;
  private:
  int _internal_address_size() const;
  public:
  void clear_address();
  const std::string& address(int index) const;
  std::string* mutable_address(int index);
  void set_address(int index, const std::string& value);
  void set_address(int index, std::string&& value);
  void set_address(int index, const char* value);
  void set_address(int index, const char* value, size_t size);
  std::string* add_address();
  void add_address(const std::string& value);
  void add_address(std::string&& value);
  void add_address(const char* value);
  void add_address(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& address() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_address();
  private:
  const std::string& _internal_address(int index) const;
  std::string* _internal_add_address();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string category = 3;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .io.openisms.v1.Person contact = 4;
  bool has_contact() const;
  private:
  bool _internal_has_contact() const;
  public:
  void clear_contact();
  const ::io::openisms::v1::Person& contact() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::Person* release_contact();
  ::io::openisms::v1::Person* mutable_contact();
  void set_allocated_contact(::io::openisms::v1::Person* contact);
  private:
  const ::io::openisms::v1::Person& _internal_contact() const;
  ::io::openisms::v1::Person* _internal_mutable_contact();
  public:
  void unsafe_arena_set_allocated_contact(
      ::io::openisms::v1::Person* contact);
  ::io::openisms::v1::Person* unsafe_arena_release_contact();

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Company)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
  ::io::openisms::v1::Person* contact_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Pentest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Pentest) */ {
 public:
  inline Pentest() : Pentest(nullptr) {}
  ~Pentest() override;
  explicit PROTOBUF_CONSTEXPR Pentest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pentest(const Pentest& from);
  Pentest(Pentest&& from) noexcept
    : Pentest() {
    *this = ::std::move(from);
  }

  inline Pentest& operator=(const Pentest& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pentest& operator=(Pentest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pentest& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pentest* internal_default_instance() {
    return reinterpret_cast<const Pentest*>(
               &_Pentest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Pentest& a, Pentest& b) {
    a.Swap(&b);
  }
  inline void Swap(Pentest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pentest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pentest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pentest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pentest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Pentest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pentest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Pentest";
  }
  protected:
  explicit Pentest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContactsFieldNumber = 9,
    kTagsFieldNumber = 10,
    kIdFieldNumber = 1,
    kFocusFieldNumber = 5,
    kResultFieldNumber = 7,
    kUrlFieldNumber = 8,
    kBeginFieldNumber = 2,
    kEndFieldNumber = 3,
    kCompanyFieldNumber = 4,
    kPassedFieldNumber = 6,
  };
  // repeated .io.openisms.v1.Person contacts = 9;
  int contacts_size() const;
  private:
  int _internal_contacts_size() const;
  public:
  void clear_contacts();
  ::io::openisms::v1::Person* mutable_contacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Person >*
      mutable_contacts();
  private:
  const ::io::openisms::v1::Person& _internal_contacts(int index) const;
  ::io::openisms::v1::Person* _internal_add_contacts();
  public:
  const ::io::openisms::v1::Person& contacts(int index) const;
  ::io::openisms::v1::Person* add_contacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Person >&
      contacts() const;

  // repeated string tags = 10;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string focus = 5;
  void clear_focus();
  const std::string& focus() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_focus(ArgT0&& arg0, ArgT... args);
  std::string* mutable_focus();
  PROTOBUF_NODISCARD std::string* release_focus();
  void set_allocated_focus(std::string* focus);
  private:
  const std::string& _internal_focus() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_focus(const std::string& value);
  std::string* _internal_mutable_focus();
  public:

  // string result = 7;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // string url = 8;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // .io.openisms.v1.Date begin = 2;
  bool has_begin() const;
  private:
  bool _internal_has_begin() const;
  public:
  void clear_begin();
  const ::io::openisms::v1::Date& begin() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::Date* release_begin();
  ::io::openisms::v1::Date* mutable_begin();
  void set_allocated_begin(::io::openisms::v1::Date* begin);
  private:
  const ::io::openisms::v1::Date& _internal_begin() const;
  ::io::openisms::v1::Date* _internal_mutable_begin();
  public:
  void unsafe_arena_set_allocated_begin(
      ::io::openisms::v1::Date* begin);
  ::io::openisms::v1::Date* unsafe_arena_release_begin();

  // .io.openisms.v1.Date end = 3;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::io::openisms::v1::Date& end() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::Date* release_end();
  ::io::openisms::v1::Date* mutable_end();
  void set_allocated_end(::io::openisms::v1::Date* end);
  private:
  const ::io::openisms::v1::Date& _internal_end() const;
  ::io::openisms::v1::Date* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::io::openisms::v1::Date* end);
  ::io::openisms::v1::Date* unsafe_arena_release_end();

  // .io.openisms.v1.Company company = 4;
  bool has_company() const;
  private:
  bool _internal_has_company() const;
  public:
  void clear_company();
  const ::io::openisms::v1::Company& company() const;
  PROTOBUF_NODISCARD ::io::openisms::v1::Company* release_company();
  ::io::openisms::v1::Company* mutable_company();
  void set_allocated_company(::io::openisms::v1::Company* company);
  private:
  const ::io::openisms::v1::Company& _internal_company() const;
  ::io::openisms::v1::Company* _internal_mutable_company();
  public:
  void unsafe_arena_set_allocated_company(
      ::io::openisms::v1::Company* company);
  ::io::openisms::v1::Company* unsafe_arena_release_company();

  // bool passed = 6;
  void clear_passed();
  bool passed() const;
  void set_passed(bool value);
  private:
  bool _internal_passed() const;
  void _internal_set_passed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Pentest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Person > contacts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr focus_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::io::openisms::v1::Date* begin_;
  ::io::openisms::v1::Date* end_;
  ::io::openisms::v1::Company* company_;
  bool passed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Repository final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Repository) */ {
 public:
  inline Repository() : Repository(nullptr) {}
  ~Repository() override;
  explicit PROTOBUF_CONSTEXPR Repository(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Repository(const Repository& from);
  Repository(Repository&& from) noexcept
    : Repository() {
    *this = ::std::move(from);
  }

  inline Repository& operator=(const Repository& from) {
    CopyFrom(from);
    return *this;
  }
  inline Repository& operator=(Repository&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Repository& default_instance() {
    return *internal_default_instance();
  }
  static inline const Repository* internal_default_instance() {
    return reinterpret_cast<const Repository*>(
               &_Repository_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Repository& a, Repository& b) {
    a.Swap(&b);
  }
  inline void Swap(Repository* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Repository* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Repository* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Repository>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Repository& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Repository& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Repository* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Repository";
  }
  protected:
  explicit Repository(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 5,
    kSecurityAttributesFieldNumber = 6,
    kTagsFieldNumber = 10,
    kNameFieldNumber = 1,
    kUrlFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kVisibilityFieldNumber = 4,
  };
  // repeated .io.openisms.v1.Person members = 5;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::io::openisms::v1::Person* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Person >*
      mutable_members();
  private:
  const ::io::openisms::v1::Person& _internal_members(int index) const;
  ::io::openisms::v1::Person* _internal_add_members();
  public:
  const ::io::openisms::v1::Person& members(int index) const;
  ::io::openisms::v1::Person* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Person >&
      members() const;

  // repeated string security_attributes = 6;
  int security_attributes_size() const;
  private:
  int _internal_security_attributes_size() const;
  public:
  void clear_security_attributes();
  const std::string& security_attributes(int index) const;
  std::string* mutable_security_attributes(int index);
  void set_security_attributes(int index, const std::string& value);
  void set_security_attributes(int index, std::string&& value);
  void set_security_attributes(int index, const char* value);
  void set_security_attributes(int index, const char* value, size_t size);
  std::string* add_security_attributes();
  void add_security_attributes(const std::string& value);
  void add_security_attributes(std::string&& value);
  void add_security_attributes(const char* value);
  void add_security_attributes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& security_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_security_attributes();
  private:
  const std::string& _internal_security_attributes(int index) const;
  std::string* _internal_add_security_attributes();
  public:

  // repeated string tags = 10;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .io.openisms.v1.Visibility visibility = 4;
  void clear_visibility();
  ::io::openisms::v1::Visibility visibility() const;
  void set_visibility(::io::openisms::v1::Visibility value);
  private:
  ::io::openisms::v1::Visibility _internal_visibility() const;
  void _internal_set_visibility(::io::openisms::v1::Visibility value);
  public:

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Repository)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Person > members_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> security_attributes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  int visibility_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Statistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.openisms.v1.Statistics) */ {
 public:
  inline Statistics() : Statistics(nullptr) {}
  ~Statistics() override;
  explicit PROTOBUF_CONSTEXPR Statistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Statistics(const Statistics& from);
  Statistics(Statistics&& from) noexcept
    : Statistics() {
    *this = ::std::move(from);
  }

  inline Statistics& operator=(const Statistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statistics& operator=(Statistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Statistics* internal_default_instance() {
    return reinterpret_cast<const Statistics*>(
               &_Statistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Statistics& a, Statistics& b) {
    a.Swap(&b);
  }
  inline void Swap(Statistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Statistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Statistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Statistics& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.openisms.v1.Statistics";
  }
  protected:
  explicit Statistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kNameFieldNumber = 2,
    kCommentFieldNumber = 4,
    kValueFieldNumber = 3,
  };
  // string identifier = 1;
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string comment = 4;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // int32 value = 3;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.openisms.v1.Statistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
  int32_t value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2fopenisms_2fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Event

// .io.openisms.v1.Meta meta = 1;
inline bool Event::_internal_has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline bool Event::has_meta() const {
  return _internal_has_meta();
}
inline void Event::clear_meta() {
  if (GetArenaForAllocation() == nullptr && meta_ != nullptr) {
    delete meta_;
  }
  meta_ = nullptr;
}
inline const ::io::openisms::v1::Meta& Event::_internal_meta() const {
  const ::io::openisms::v1::Meta* p = meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::Meta&>(
      ::io::openisms::v1::_Meta_default_instance_);
}
inline const ::io::openisms::v1::Meta& Event::meta() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Event.meta)
  return _internal_meta();
}
inline void Event::unsafe_arena_set_allocated_meta(
    ::io::openisms::v1::Meta* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  meta_ = meta;
  if (meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Event.meta)
}
inline ::io::openisms::v1::Meta* Event::release_meta() {
  
  ::io::openisms::v1::Meta* temp = meta_;
  meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::Meta* Event::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Event.meta)
  
  ::io::openisms::v1::Meta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::Meta* Event::_internal_mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::Meta>(GetArenaForAllocation());
    meta_ = p;
  }
  return meta_;
}
inline ::io::openisms::v1::Meta* Event::mutable_meta() {
  ::io::openisms::v1::Meta* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Event.meta)
  return _msg;
}
inline void Event::set_allocated_meta(::io::openisms::v1::Meta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(meta);
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Event.meta)
}

// .io.openisms.v1.SourceSystem source = 2;
inline bool Event::_internal_has_source() const {
  return this != internal_default_instance() && source_ != nullptr;
}
inline bool Event::has_source() const {
  return _internal_has_source();
}
inline void Event::clear_source() {
  if (GetArenaForAllocation() == nullptr && source_ != nullptr) {
    delete source_;
  }
  source_ = nullptr;
}
inline const ::io::openisms::v1::SourceSystem& Event::_internal_source() const {
  const ::io::openisms::v1::SourceSystem* p = source_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::SourceSystem&>(
      ::io::openisms::v1::_SourceSystem_default_instance_);
}
inline const ::io::openisms::v1::SourceSystem& Event::source() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Event.source)
  return _internal_source();
}
inline void Event::unsafe_arena_set_allocated_source(
    ::io::openisms::v1::SourceSystem* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Event.source)
}
inline ::io::openisms::v1::SourceSystem* Event::release_source() {
  
  ::io::openisms::v1::SourceSystem* temp = source_;
  source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::SourceSystem* Event::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Event.source)
  
  ::io::openisms::v1::SourceSystem* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::SourceSystem* Event::_internal_mutable_source() {
  
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::SourceSystem>(GetArenaForAllocation());
    source_ = p;
  }
  return source_;
}
inline ::io::openisms::v1::SourceSystem* Event::mutable_source() {
  ::io::openisms::v1::SourceSystem* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Event.source)
  return _msg;
}
inline void Event::set_allocated_source(::io::openisms::v1::SourceSystem* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Event.source)
}

// repeated .io.openisms.v1.User users = 3;
inline int Event::_internal_users_size() const {
  return users_.size();
}
inline int Event::users_size() const {
  return _internal_users_size();
}
inline void Event::clear_users() {
  users_.Clear();
}
inline ::io::openisms::v1::User* Event::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Event.users)
  return users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::User >*
Event::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Event.users)
  return &users_;
}
inline const ::io::openisms::v1::User& Event::_internal_users(int index) const {
  return users_.Get(index);
}
inline const ::io::openisms::v1::User& Event::users(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Event.users)
  return _internal_users(index);
}
inline ::io::openisms::v1::User* Event::_internal_add_users() {
  return users_.Add();
}
inline ::io::openisms::v1::User* Event::add_users() {
  ::io::openisms::v1::User* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:io.openisms.v1.Event.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::User >&
Event::users() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Event.users)
  return users_;
}

// repeated .io.openisms.v1.PhysicalObject devices = 4;
inline int Event::_internal_devices_size() const {
  return devices_.size();
}
inline int Event::devices_size() const {
  return _internal_devices_size();
}
inline void Event::clear_devices() {
  devices_.Clear();
}
inline ::io::openisms::v1::PhysicalObject* Event::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Event.devices)
  return devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::PhysicalObject >*
Event::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Event.devices)
  return &devices_;
}
inline const ::io::openisms::v1::PhysicalObject& Event::_internal_devices(int index) const {
  return devices_.Get(index);
}
inline const ::io::openisms::v1::PhysicalObject& Event::devices(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Event.devices)
  return _internal_devices(index);
}
inline ::io::openisms::v1::PhysicalObject* Event::_internal_add_devices() {
  return devices_.Add();
}
inline ::io::openisms::v1::PhysicalObject* Event::add_devices() {
  ::io::openisms::v1::PhysicalObject* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:io.openisms.v1.Event.devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::PhysicalObject >&
Event::devices() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Event.devices)
  return devices_;
}

// repeated .io.openisms.v1.Repository repositories = 7;
inline int Event::_internal_repositories_size() const {
  return repositories_.size();
}
inline int Event::repositories_size() const {
  return _internal_repositories_size();
}
inline void Event::clear_repositories() {
  repositories_.Clear();
}
inline ::io::openisms::v1::Repository* Event::mutable_repositories(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Event.repositories)
  return repositories_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Repository >*
Event::mutable_repositories() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Event.repositories)
  return &repositories_;
}
inline const ::io::openisms::v1::Repository& Event::_internal_repositories(int index) const {
  return repositories_.Get(index);
}
inline const ::io::openisms::v1::Repository& Event::repositories(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Event.repositories)
  return _internal_repositories(index);
}
inline ::io::openisms::v1::Repository* Event::_internal_add_repositories() {
  return repositories_.Add();
}
inline ::io::openisms::v1::Repository* Event::add_repositories() {
  ::io::openisms::v1::Repository* _add = _internal_add_repositories();
  // @@protoc_insertion_point(field_add:io.openisms.v1.Event.repositories)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Repository >&
Event::repositories() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Event.repositories)
  return repositories_;
}

// repeated .io.openisms.v1.Certification certification = 9;
inline int Event::_internal_certification_size() const {
  return certification_.size();
}
inline int Event::certification_size() const {
  return _internal_certification_size();
}
inline void Event::clear_certification() {
  certification_.Clear();
}
inline ::io::openisms::v1::Certification* Event::mutable_certification(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Event.certification)
  return certification_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Certification >*
Event::mutable_certification() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Event.certification)
  return &certification_;
}
inline const ::io::openisms::v1::Certification& Event::_internal_certification(int index) const {
  return certification_.Get(index);
}
inline const ::io::openisms::v1::Certification& Event::certification(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Event.certification)
  return _internal_certification(index);
}
inline ::io::openisms::v1::Certification* Event::_internal_add_certification() {
  return certification_.Add();
}
inline ::io::openisms::v1::Certification* Event::add_certification() {
  ::io::openisms::v1::Certification* _add = _internal_add_certification();
  // @@protoc_insertion_point(field_add:io.openisms.v1.Event.certification)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Certification >&
Event::certification() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Event.certification)
  return certification_;
}

// repeated .io.openisms.v1.Pentest pentest = 11;
inline int Event::_internal_pentest_size() const {
  return pentest_.size();
}
inline int Event::pentest_size() const {
  return _internal_pentest_size();
}
inline void Event::clear_pentest() {
  pentest_.Clear();
}
inline ::io::openisms::v1::Pentest* Event::mutable_pentest(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Event.pentest)
  return pentest_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Pentest >*
Event::mutable_pentest() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Event.pentest)
  return &pentest_;
}
inline const ::io::openisms::v1::Pentest& Event::_internal_pentest(int index) const {
  return pentest_.Get(index);
}
inline const ::io::openisms::v1::Pentest& Event::pentest(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Event.pentest)
  return _internal_pentest(index);
}
inline ::io::openisms::v1::Pentest* Event::_internal_add_pentest() {
  return pentest_.Add();
}
inline ::io::openisms::v1::Pentest* Event::add_pentest() {
  ::io::openisms::v1::Pentest* _add = _internal_add_pentest();
  // @@protoc_insertion_point(field_add:io.openisms.v1.Event.pentest)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Pentest >&
Event::pentest() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Event.pentest)
  return pentest_;
}

// repeated .io.openisms.v1.Statistics stats = 13;
inline int Event::_internal_stats_size() const {
  return stats_.size();
}
inline int Event::stats_size() const {
  return _internal_stats_size();
}
inline void Event::clear_stats() {
  stats_.Clear();
}
inline ::io::openisms::v1::Statistics* Event::mutable_stats(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Event.stats)
  return stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Statistics >*
Event::mutable_stats() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Event.stats)
  return &stats_;
}
inline const ::io::openisms::v1::Statistics& Event::_internal_stats(int index) const {
  return stats_.Get(index);
}
inline const ::io::openisms::v1::Statistics& Event::stats(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Event.stats)
  return _internal_stats(index);
}
inline ::io::openisms::v1::Statistics* Event::_internal_add_stats() {
  return stats_.Add();
}
inline ::io::openisms::v1::Statistics* Event::add_stats() {
  ::io::openisms::v1::Statistics* _add = _internal_add_stats();
  // @@protoc_insertion_point(field_add:io.openisms.v1.Event.stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Statistics >&
Event::stats() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Event.stats)
  return stats_;
}

// -------------------------------------------------------------------

// Meta

// .google.protobuf.Timestamp created = 1;
inline bool Meta::_internal_has_created() const {
  return this != internal_default_instance() && created_ != nullptr;
}
inline bool Meta::has_created() const {
  return _internal_has_created();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Meta::_internal_created() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Meta::created() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Meta.created)
  return _internal_created();
}
inline void Meta::unsafe_arena_set_allocated_created(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_);
  }
  created_ = created;
  if (created) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Meta.created)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Meta::release_created() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_;
  created_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Meta::unsafe_arena_release_created() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Meta.created)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_;
  created_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Meta::_internal_mutable_created() {
  
  if (created_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_ = p;
  }
  return created_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Meta::mutable_created() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Meta.created)
  return _msg;
}
inline void Meta::set_allocated_created(::PROTOBUF_NAMESPACE_ID::Timestamp* created) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_);
  }
  if (created) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created));
    if (message_arena != submessage_arena) {
      created = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created, submessage_arena);
    }
    
  } else {
    
  }
  created_ = created;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Meta.created)
}

// string identifier = 2;
inline void Meta::clear_identifier() {
  identifier_.ClearToEmpty();
}
inline const std::string& Meta::identifier() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Meta.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Meta::set_identifier(ArgT0&& arg0, ArgT... args) {
 
 identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Meta.identifier)
}
inline std::string* Meta::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Meta.identifier)
  return _s;
}
inline const std::string& Meta::_internal_identifier() const {
  return identifier_.Get();
}
inline void Meta::_internal_set_identifier(const std::string& value) {
  
  identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* Meta::_internal_mutable_identifier() {
  
  return identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* Meta::release_identifier() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Meta.identifier)
  return identifier_.Release();
}
inline void Meta::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    
  } else {
    
  }
  identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Meta.identifier)
}

// string etag = 3;
inline void Meta::clear_etag() {
  etag_.ClearToEmpty();
}
inline const std::string& Meta::etag() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Meta.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Meta::set_etag(ArgT0&& arg0, ArgT... args) {
 
 etag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Meta.etag)
}
inline std::string* Meta::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Meta.etag)
  return _s;
}
inline const std::string& Meta::_internal_etag() const {
  return etag_.Get();
}
inline void Meta::_internal_set_etag(const std::string& value) {
  
  etag_.Set(value, GetArenaForAllocation());
}
inline std::string* Meta::_internal_mutable_etag() {
  
  return etag_.Mutable(GetArenaForAllocation());
}
inline std::string* Meta::release_etag() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Meta.etag)
  return etag_.Release();
}
inline void Meta::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    
  } else {
    
  }
  etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault()) {
    etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Meta.etag)
}

// -------------------------------------------------------------------

// SourceSystem

// string name = 1;
inline void SourceSystem::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& SourceSystem::name() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SourceSystem.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SourceSystem::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.SourceSystem.name)
}
inline std::string* SourceSystem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.SourceSystem.name)
  return _s;
}
inline const std::string& SourceSystem::_internal_name() const {
  return name_.Get();
}
inline void SourceSystem::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* SourceSystem::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* SourceSystem::release_name() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.SourceSystem.name)
  return name_.Release();
}
inline void SourceSystem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.SourceSystem.name)
}

// string vendor = 2;
inline void SourceSystem::clear_vendor() {
  vendor_.ClearToEmpty();
}
inline const std::string& SourceSystem::vendor() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SourceSystem.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SourceSystem::set_vendor(ArgT0&& arg0, ArgT... args) {
 
 vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.SourceSystem.vendor)
}
inline std::string* SourceSystem::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.SourceSystem.vendor)
  return _s;
}
inline const std::string& SourceSystem::_internal_vendor() const {
  return vendor_.Get();
}
inline void SourceSystem::_internal_set_vendor(const std::string& value) {
  
  vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* SourceSystem::_internal_mutable_vendor() {
  
  return vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* SourceSystem::release_vendor() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.SourceSystem.vendor)
  return vendor_.Release();
}
inline void SourceSystem::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    
  } else {
    
  }
  vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vendor_.IsDefault()) {
    vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.SourceSystem.vendor)
}

// string url = 3;
inline void SourceSystem::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& SourceSystem::url() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SourceSystem.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SourceSystem::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.SourceSystem.url)
}
inline std::string* SourceSystem::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.SourceSystem.url)
  return _s;
}
inline const std::string& SourceSystem::_internal_url() const {
  return url_.Get();
}
inline void SourceSystem::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* SourceSystem::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* SourceSystem::release_url() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.SourceSystem.url)
  return url_.Release();
}
inline void SourceSystem::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.SourceSystem.url)
}

// string logo_url = 4;
inline void SourceSystem::clear_logo_url() {
  logo_url_.ClearToEmpty();
}
inline const std::string& SourceSystem::logo_url() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SourceSystem.logo_url)
  return _internal_logo_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SourceSystem::set_logo_url(ArgT0&& arg0, ArgT... args) {
 
 logo_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.SourceSystem.logo_url)
}
inline std::string* SourceSystem::mutable_logo_url() {
  std::string* _s = _internal_mutable_logo_url();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.SourceSystem.logo_url)
  return _s;
}
inline const std::string& SourceSystem::_internal_logo_url() const {
  return logo_url_.Get();
}
inline void SourceSystem::_internal_set_logo_url(const std::string& value) {
  
  logo_url_.Set(value, GetArenaForAllocation());
}
inline std::string* SourceSystem::_internal_mutable_logo_url() {
  
  return logo_url_.Mutable(GetArenaForAllocation());
}
inline std::string* SourceSystem::release_logo_url() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.SourceSystem.logo_url)
  return logo_url_.Release();
}
inline void SourceSystem::set_allocated_logo_url(std::string* logo_url) {
  if (logo_url != nullptr) {
    
  } else {
    
  }
  logo_url_.SetAllocated(logo_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (logo_url_.IsDefault()) {
    logo_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.SourceSystem.logo_url)
}

// .io.openisms.v1.SourceSystem.SourceType type = 5;
inline void SourceSystem::clear_type() {
  type_ = 0;
}
inline ::io::openisms::v1::SourceSystem_SourceType SourceSystem::_internal_type() const {
  return static_cast< ::io::openisms::v1::SourceSystem_SourceType >(type_);
}
inline ::io::openisms::v1::SourceSystem_SourceType SourceSystem::type() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SourceSystem.type)
  return _internal_type();
}
inline void SourceSystem::_internal_set_type(::io::openisms::v1::SourceSystem_SourceType value) {
  
  type_ = value;
}
inline void SourceSystem::set_type(::io::openisms::v1::SourceSystem_SourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.SourceSystem.type)
}

// -------------------------------------------------------------------

// User

// .io.openisms.v1.Person person = 1;
inline bool User::_internal_has_person() const {
  return this != internal_default_instance() && person_ != nullptr;
}
inline bool User::has_person() const {
  return _internal_has_person();
}
inline void User::clear_person() {
  if (GetArenaForAllocation() == nullptr && person_ != nullptr) {
    delete person_;
  }
  person_ = nullptr;
}
inline const ::io::openisms::v1::Person& User::_internal_person() const {
  const ::io::openisms::v1::Person* p = person_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::Person&>(
      ::io::openisms::v1::_Person_default_instance_);
}
inline const ::io::openisms::v1::Person& User::person() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.User.person)
  return _internal_person();
}
inline void User::unsafe_arena_set_allocated_person(
    ::io::openisms::v1::Person* person) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(person_);
  }
  person_ = person;
  if (person) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.User.person)
}
inline ::io::openisms::v1::Person* User::release_person() {
  
  ::io::openisms::v1::Person* temp = person_;
  person_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::Person* User::unsafe_arena_release_person() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.User.person)
  
  ::io::openisms::v1::Person* temp = person_;
  person_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::Person* User::_internal_mutable_person() {
  
  if (person_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::Person>(GetArenaForAllocation());
    person_ = p;
  }
  return person_;
}
inline ::io::openisms::v1::Person* User::mutable_person() {
  ::io::openisms::v1::Person* _msg = _internal_mutable_person();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.User.person)
  return _msg;
}
inline void User::set_allocated_person(::io::openisms::v1::Person* person) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete person_;
  }
  if (person) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(person);
    if (message_arena != submessage_arena) {
      person = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, person, submessage_arena);
    }
    
  } else {
    
  }
  person_ = person;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.User.person)
}

// .google.protobuf.BoolValue second_factor_active = 5;
inline bool User::_internal_has_second_factor_active() const {
  return this != internal_default_instance() && second_factor_active_ != nullptr;
}
inline bool User::has_second_factor_active() const {
  return _internal_has_second_factor_active();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& User::_internal_second_factor_active() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = second_factor_active_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& User::second_factor_active() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.User.second_factor_active)
  return _internal_second_factor_active();
}
inline void User::unsafe_arena_set_allocated_second_factor_active(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* second_factor_active) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(second_factor_active_);
  }
  second_factor_active_ = second_factor_active;
  if (second_factor_active) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.User.second_factor_active)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::release_second_factor_active() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = second_factor_active_;
  second_factor_active_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::unsafe_arena_release_second_factor_active() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.User.second_factor_active)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = second_factor_active_;
  second_factor_active_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::_internal_mutable_second_factor_active() {
  
  if (second_factor_active_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    second_factor_active_ = p;
  }
  return second_factor_active_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::mutable_second_factor_active() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_second_factor_active();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.User.second_factor_active)
  return _msg;
}
inline void User::set_allocated_second_factor_active(::PROTOBUF_NAMESPACE_ID::BoolValue* second_factor_active) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(second_factor_active_);
  }
  if (second_factor_active) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(second_factor_active));
    if (message_arena != submessage_arena) {
      second_factor_active = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, second_factor_active, submessage_arena);
    }
    
  } else {
    
  }
  second_factor_active_ = second_factor_active;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.User.second_factor_active)
}

// .google.protobuf.BoolValue second_factor_enforced = 6;
inline bool User::_internal_has_second_factor_enforced() const {
  return this != internal_default_instance() && second_factor_enforced_ != nullptr;
}
inline bool User::has_second_factor_enforced() const {
  return _internal_has_second_factor_enforced();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& User::_internal_second_factor_enforced() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = second_factor_enforced_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& User::second_factor_enforced() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.User.second_factor_enforced)
  return _internal_second_factor_enforced();
}
inline void User::unsafe_arena_set_allocated_second_factor_enforced(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* second_factor_enforced) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(second_factor_enforced_);
  }
  second_factor_enforced_ = second_factor_enforced;
  if (second_factor_enforced) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.User.second_factor_enforced)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::release_second_factor_enforced() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = second_factor_enforced_;
  second_factor_enforced_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::unsafe_arena_release_second_factor_enforced() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.User.second_factor_enforced)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = second_factor_enforced_;
  second_factor_enforced_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::_internal_mutable_second_factor_enforced() {
  
  if (second_factor_enforced_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    second_factor_enforced_ = p;
  }
  return second_factor_enforced_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::mutable_second_factor_enforced() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_second_factor_enforced();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.User.second_factor_enforced)
  return _msg;
}
inline void User::set_allocated_second_factor_enforced(::PROTOBUF_NAMESPACE_ID::BoolValue* second_factor_enforced) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(second_factor_enforced_);
  }
  if (second_factor_enforced) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(second_factor_enforced));
    if (message_arena != submessage_arena) {
      second_factor_enforced = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, second_factor_enforced, submessage_arena);
    }
    
  } else {
    
  }
  second_factor_enforced_ = second_factor_enforced;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.User.second_factor_enforced)
}

// .google.protobuf.BoolValue active = 7;
inline bool User::_internal_has_active() const {
  return this != internal_default_instance() && active_ != nullptr;
}
inline bool User::has_active() const {
  return _internal_has_active();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& User::_internal_active() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = active_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& User::active() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.User.active)
  return _internal_active();
}
inline void User::unsafe_arena_set_allocated_active(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* active) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(active_);
  }
  active_ = active;
  if (active) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.User.active)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::release_active() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = active_;
  active_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::unsafe_arena_release_active() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.User.active)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = active_;
  active_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::_internal_mutable_active() {
  
  if (active_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    active_ = p;
  }
  return active_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::mutable_active() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_active();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.User.active)
  return _msg;
}
inline void User::set_allocated_active(::PROTOBUF_NAMESPACE_ID::BoolValue* active) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(active_);
  }
  if (active) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(active));
    if (message_arena != submessage_arena) {
      active = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active, submessage_arena);
    }
    
  } else {
    
  }
  active_ = active;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.User.active)
}

// .google.protobuf.BoolValue suspended = 8;
inline bool User::_internal_has_suspended() const {
  return this != internal_default_instance() && suspended_ != nullptr;
}
inline bool User::has_suspended() const {
  return _internal_has_suspended();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& User::_internal_suspended() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = suspended_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& User::suspended() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.User.suspended)
  return _internal_suspended();
}
inline void User::unsafe_arena_set_allocated_suspended(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* suspended) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suspended_);
  }
  suspended_ = suspended;
  if (suspended) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.User.suspended)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::release_suspended() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = suspended_;
  suspended_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::unsafe_arena_release_suspended() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.User.suspended)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = suspended_;
  suspended_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::_internal_mutable_suspended() {
  
  if (suspended_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    suspended_ = p;
  }
  return suspended_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::mutable_suspended() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_suspended();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.User.suspended)
  return _msg;
}
inline void User::set_allocated_suspended(::PROTOBUF_NAMESPACE_ID::BoolValue* suspended) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(suspended_);
  }
  if (suspended) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suspended));
    if (message_arena != submessage_arena) {
      suspended = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, suspended, submessage_arena);
    }
    
  } else {
    
  }
  suspended_ = suspended;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.User.suspended)
}

// .google.protobuf.BoolValue disabled = 9;
inline bool User::_internal_has_disabled() const {
  return this != internal_default_instance() && disabled_ != nullptr;
}
inline bool User::has_disabled() const {
  return _internal_has_disabled();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& User::_internal_disabled() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = disabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& User::disabled() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.User.disabled)
  return _internal_disabled();
}
inline void User::unsafe_arena_set_allocated_disabled(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* disabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(disabled_);
  }
  disabled_ = disabled;
  if (disabled) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.User.disabled)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::release_disabled() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = disabled_;
  disabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::unsafe_arena_release_disabled() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.User.disabled)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = disabled_;
  disabled_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::_internal_mutable_disabled() {
  
  if (disabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    disabled_ = p;
  }
  return disabled_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::mutable_disabled() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_disabled();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.User.disabled)
  return _msg;
}
inline void User::set_allocated_disabled(::PROTOBUF_NAMESPACE_ID::BoolValue* disabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(disabled_);
  }
  if (disabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(disabled));
    if (message_arena != submessage_arena) {
      disabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disabled, submessage_arena);
    }
    
  } else {
    
  }
  disabled_ = disabled;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.User.disabled)
}

// .google.protobuf.BoolValue deleted = 10;
inline bool User::_internal_has_deleted() const {
  return this != internal_default_instance() && deleted_ != nullptr;
}
inline bool User::has_deleted() const {
  return _internal_has_deleted();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& User::_internal_deleted() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = deleted_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& User::deleted() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.User.deleted)
  return _internal_deleted();
}
inline void User::unsafe_arena_set_allocated_deleted(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* deleted) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_);
  }
  deleted_ = deleted;
  if (deleted) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.User.deleted)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::release_deleted() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = deleted_;
  deleted_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::unsafe_arena_release_deleted() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.User.deleted)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = deleted_;
  deleted_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::_internal_mutable_deleted() {
  
  if (deleted_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    deleted_ = p;
  }
  return deleted_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* User::mutable_deleted() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_deleted();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.User.deleted)
  return _msg;
}
inline void User::set_allocated_deleted(::PROTOBUF_NAMESPACE_ID::BoolValue* deleted) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_);
  }
  if (deleted) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted));
    if (message_arena != submessage_arena) {
      deleted = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleted, submessage_arena);
    }
    
  } else {
    
  }
  deleted_ = deleted;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.User.deleted)
}

// repeated string groups = 15;
inline int User::_internal_groups_size() const {
  return groups_.size();
}
inline int User::groups_size() const {
  return _internal_groups_size();
}
inline void User::clear_groups() {
  groups_.Clear();
}
inline std::string* User::add_groups() {
  std::string* _s = _internal_add_groups();
  // @@protoc_insertion_point(field_add_mutable:io.openisms.v1.User.groups)
  return _s;
}
inline const std::string& User::_internal_groups(int index) const {
  return groups_.Get(index);
}
inline const std::string& User::groups(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.User.groups)
  return _internal_groups(index);
}
inline std::string* User::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.User.groups)
  return groups_.Mutable(index);
}
inline void User::set_groups(int index, const std::string& value) {
  groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.User.groups)
}
inline void User::set_groups(int index, std::string&& value) {
  groups_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.openisms.v1.User.groups)
}
inline void User::set_groups(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.openisms.v1.User.groups)
}
inline void User::set_groups(int index, const char* value, size_t size) {
  groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.openisms.v1.User.groups)
}
inline std::string* User::_internal_add_groups() {
  return groups_.Add();
}
inline void User::add_groups(const std::string& value) {
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.openisms.v1.User.groups)
}
inline void User::add_groups(std::string&& value) {
  groups_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.openisms.v1.User.groups)
}
inline void User::add_groups(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.openisms.v1.User.groups)
}
inline void User::add_groups(const char* value, size_t size) {
  groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.openisms.v1.User.groups)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
User::groups() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.User.groups)
  return groups_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
User::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.User.groups)
  return &groups_;
}

// repeated string privileges = 16;
inline int User::_internal_privileges_size() const {
  return privileges_.size();
}
inline int User::privileges_size() const {
  return _internal_privileges_size();
}
inline void User::clear_privileges() {
  privileges_.Clear();
}
inline std::string* User::add_privileges() {
  std::string* _s = _internal_add_privileges();
  // @@protoc_insertion_point(field_add_mutable:io.openisms.v1.User.privileges)
  return _s;
}
inline const std::string& User::_internal_privileges(int index) const {
  return privileges_.Get(index);
}
inline const std::string& User::privileges(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.User.privileges)
  return _internal_privileges(index);
}
inline std::string* User::mutable_privileges(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.User.privileges)
  return privileges_.Mutable(index);
}
inline void User::set_privileges(int index, const std::string& value) {
  privileges_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.User.privileges)
}
inline void User::set_privileges(int index, std::string&& value) {
  privileges_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.openisms.v1.User.privileges)
}
inline void User::set_privileges(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  privileges_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.openisms.v1.User.privileges)
}
inline void User::set_privileges(int index, const char* value, size_t size) {
  privileges_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.openisms.v1.User.privileges)
}
inline std::string* User::_internal_add_privileges() {
  return privileges_.Add();
}
inline void User::add_privileges(const std::string& value) {
  privileges_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.openisms.v1.User.privileges)
}
inline void User::add_privileges(std::string&& value) {
  privileges_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.openisms.v1.User.privileges)
}
inline void User::add_privileges(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  privileges_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.openisms.v1.User.privileges)
}
inline void User::add_privileges(const char* value, size_t size) {
  privileges_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.openisms.v1.User.privileges)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
User::privileges() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.User.privileges)
  return privileges_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
User::mutable_privileges() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.User.privileges)
  return &privileges_;
}

// .io.openisms.v1.Employment employment = 20;
inline bool User::_internal_has_employment() const {
  return this != internal_default_instance() && employment_ != nullptr;
}
inline bool User::has_employment() const {
  return _internal_has_employment();
}
inline void User::clear_employment() {
  if (GetArenaForAllocation() == nullptr && employment_ != nullptr) {
    delete employment_;
  }
  employment_ = nullptr;
}
inline const ::io::openisms::v1::Employment& User::_internal_employment() const {
  const ::io::openisms::v1::Employment* p = employment_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::Employment&>(
      ::io::openisms::v1::_Employment_default_instance_);
}
inline const ::io::openisms::v1::Employment& User::employment() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.User.employment)
  return _internal_employment();
}
inline void User::unsafe_arena_set_allocated_employment(
    ::io::openisms::v1::Employment* employment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(employment_);
  }
  employment_ = employment;
  if (employment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.User.employment)
}
inline ::io::openisms::v1::Employment* User::release_employment() {
  
  ::io::openisms::v1::Employment* temp = employment_;
  employment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::Employment* User::unsafe_arena_release_employment() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.User.employment)
  
  ::io::openisms::v1::Employment* temp = employment_;
  employment_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::Employment* User::_internal_mutable_employment() {
  
  if (employment_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::Employment>(GetArenaForAllocation());
    employment_ = p;
  }
  return employment_;
}
inline ::io::openisms::v1::Employment* User::mutable_employment() {
  ::io::openisms::v1::Employment* _msg = _internal_mutable_employment();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.User.employment)
  return _msg;
}
inline void User::set_allocated_employment(::io::openisms::v1::Employment* employment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete employment_;
  }
  if (employment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(employment);
    if (message_arena != submessage_arena) {
      employment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, employment, submessage_arena);
    }
    
  } else {
    
  }
  employment_ = employment;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.User.employment)
}

// repeated .io.openisms.v1.ConnectedAccount connected_accounts = 21;
inline int User::_internal_connected_accounts_size() const {
  return connected_accounts_.size();
}
inline int User::connected_accounts_size() const {
  return _internal_connected_accounts_size();
}
inline void User::clear_connected_accounts() {
  connected_accounts_.Clear();
}
inline ::io::openisms::v1::ConnectedAccount* User::mutable_connected_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.User.connected_accounts)
  return connected_accounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::ConnectedAccount >*
User::mutable_connected_accounts() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.User.connected_accounts)
  return &connected_accounts_;
}
inline const ::io::openisms::v1::ConnectedAccount& User::_internal_connected_accounts(int index) const {
  return connected_accounts_.Get(index);
}
inline const ::io::openisms::v1::ConnectedAccount& User::connected_accounts(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.User.connected_accounts)
  return _internal_connected_accounts(index);
}
inline ::io::openisms::v1::ConnectedAccount* User::_internal_add_connected_accounts() {
  return connected_accounts_.Add();
}
inline ::io::openisms::v1::ConnectedAccount* User::add_connected_accounts() {
  ::io::openisms::v1::ConnectedAccount* _add = _internal_add_connected_accounts();
  // @@protoc_insertion_point(field_add:io.openisms.v1.User.connected_accounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::ConnectedAccount >&
User::connected_accounts() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.User.connected_accounts)
  return connected_accounts_;
}

// repeated .io.openisms.v1.PhysicalObject possessions = 22;
inline int User::_internal_possessions_size() const {
  return possessions_.size();
}
inline int User::possessions_size() const {
  return _internal_possessions_size();
}
inline void User::clear_possessions() {
  possessions_.Clear();
}
inline ::io::openisms::v1::PhysicalObject* User::mutable_possessions(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.User.possessions)
  return possessions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::PhysicalObject >*
User::mutable_possessions() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.User.possessions)
  return &possessions_;
}
inline const ::io::openisms::v1::PhysicalObject& User::_internal_possessions(int index) const {
  return possessions_.Get(index);
}
inline const ::io::openisms::v1::PhysicalObject& User::possessions(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.User.possessions)
  return _internal_possessions(index);
}
inline ::io::openisms::v1::PhysicalObject* User::_internal_add_possessions() {
  return possessions_.Add();
}
inline ::io::openisms::v1::PhysicalObject* User::add_possessions() {
  ::io::openisms::v1::PhysicalObject* _add = _internal_add_possessions();
  // @@protoc_insertion_point(field_add:io.openisms.v1.User.possessions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::PhysicalObject >&
User::possessions() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.User.possessions)
  return possessions_;
}

// repeated string tags = 40;
inline int User::_internal_tags_size() const {
  return tags_.size();
}
inline int User::tags_size() const {
  return _internal_tags_size();
}
inline void User::clear_tags() {
  tags_.Clear();
}
inline std::string* User::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:io.openisms.v1.User.tags)
  return _s;
}
inline const std::string& User::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& User::tags(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.User.tags)
  return _internal_tags(index);
}
inline std::string* User::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.User.tags)
  return tags_.Mutable(index);
}
inline void User::set_tags(int index, const std::string& value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.User.tags)
}
inline void User::set_tags(int index, std::string&& value) {
  tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.openisms.v1.User.tags)
}
inline void User::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.openisms.v1.User.tags)
}
inline void User::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.openisms.v1.User.tags)
}
inline std::string* User::_internal_add_tags() {
  return tags_.Add();
}
inline void User::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.openisms.v1.User.tags)
}
inline void User::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.openisms.v1.User.tags)
}
inline void User::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.openisms.v1.User.tags)
}
inline void User::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.openisms.v1.User.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
User::tags() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.User.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
User::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.User.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// Person

// string id = 1;
inline void Person::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Person::id() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Person.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Person::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Person.id)
}
inline std::string* Person::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Person.id)
  return _s;
}
inline const std::string& Person::_internal_id() const {
  return id_.Get();
}
inline void Person::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Person::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Person::release_id() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Person.id)
  return id_.Release();
}
inline void Person::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Person.id)
}

// .io.openisms.v1.Name name = 2;
inline bool Person::_internal_has_name() const {
  return this != internal_default_instance() && name_ != nullptr;
}
inline bool Person::has_name() const {
  return _internal_has_name();
}
inline void Person::clear_name() {
  if (GetArenaForAllocation() == nullptr && name_ != nullptr) {
    delete name_;
  }
  name_ = nullptr;
}
inline const ::io::openisms::v1::Name& Person::_internal_name() const {
  const ::io::openisms::v1::Name* p = name_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::Name&>(
      ::io::openisms::v1::_Name_default_instance_);
}
inline const ::io::openisms::v1::Name& Person::name() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Person.name)
  return _internal_name();
}
inline void Person::unsafe_arena_set_allocated_name(
    ::io::openisms::v1::Name* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  name_ = name;
  if (name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Person.name)
}
inline ::io::openisms::v1::Name* Person::release_name() {
  
  ::io::openisms::v1::Name* temp = name_;
  name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::Name* Person::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Person.name)
  
  ::io::openisms::v1::Name* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::Name* Person::_internal_mutable_name() {
  
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::Name>(GetArenaForAllocation());
    name_ = p;
  }
  return name_;
}
inline ::io::openisms::v1::Name* Person::mutable_name() {
  ::io::openisms::v1::Name* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Person.name)
  return _msg;
}
inline void Person::set_allocated_name(::io::openisms::v1::Name* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete name_;
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(name);
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Person.name)
}

// string primary_email = 3;
inline void Person::clear_primary_email() {
  primary_email_.ClearToEmpty();
}
inline const std::string& Person::primary_email() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Person.primary_email)
  return _internal_primary_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Person::set_primary_email(ArgT0&& arg0, ArgT... args) {
 
 primary_email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Person.primary_email)
}
inline std::string* Person::mutable_primary_email() {
  std::string* _s = _internal_mutable_primary_email();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Person.primary_email)
  return _s;
}
inline const std::string& Person::_internal_primary_email() const {
  return primary_email_.Get();
}
inline void Person::_internal_set_primary_email(const std::string& value) {
  
  primary_email_.Set(value, GetArenaForAllocation());
}
inline std::string* Person::_internal_mutable_primary_email() {
  
  return primary_email_.Mutable(GetArenaForAllocation());
}
inline std::string* Person::release_primary_email() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Person.primary_email)
  return primary_email_.Release();
}
inline void Person::set_allocated_primary_email(std::string* primary_email) {
  if (primary_email != nullptr) {
    
  } else {
    
  }
  primary_email_.SetAllocated(primary_email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (primary_email_.IsDefault()) {
    primary_email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Person.primary_email)
}

// repeated string other_emails = 4;
inline int Person::_internal_other_emails_size() const {
  return other_emails_.size();
}
inline int Person::other_emails_size() const {
  return _internal_other_emails_size();
}
inline void Person::clear_other_emails() {
  other_emails_.Clear();
}
inline std::string* Person::add_other_emails() {
  std::string* _s = _internal_add_other_emails();
  // @@protoc_insertion_point(field_add_mutable:io.openisms.v1.Person.other_emails)
  return _s;
}
inline const std::string& Person::_internal_other_emails(int index) const {
  return other_emails_.Get(index);
}
inline const std::string& Person::other_emails(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Person.other_emails)
  return _internal_other_emails(index);
}
inline std::string* Person::mutable_other_emails(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Person.other_emails)
  return other_emails_.Mutable(index);
}
inline void Person::set_other_emails(int index, const std::string& value) {
  other_emails_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.Person.other_emails)
}
inline void Person::set_other_emails(int index, std::string&& value) {
  other_emails_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.openisms.v1.Person.other_emails)
}
inline void Person::set_other_emails(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  other_emails_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.openisms.v1.Person.other_emails)
}
inline void Person::set_other_emails(int index, const char* value, size_t size) {
  other_emails_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.openisms.v1.Person.other_emails)
}
inline std::string* Person::_internal_add_other_emails() {
  return other_emails_.Add();
}
inline void Person::add_other_emails(const std::string& value) {
  other_emails_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.openisms.v1.Person.other_emails)
}
inline void Person::add_other_emails(std::string&& value) {
  other_emails_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.openisms.v1.Person.other_emails)
}
inline void Person::add_other_emails(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  other_emails_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.openisms.v1.Person.other_emails)
}
inline void Person::add_other_emails(const char* value, size_t size) {
  other_emails_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.openisms.v1.Person.other_emails)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Person::other_emails() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Person.other_emails)
  return other_emails_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Person::mutable_other_emails() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Person.other_emails)
  return &other_emails_;
}

// .io.openisms.v1.Photo picture = 5;
inline bool Person::_internal_has_picture() const {
  return this != internal_default_instance() && picture_ != nullptr;
}
inline bool Person::has_picture() const {
  return _internal_has_picture();
}
inline void Person::clear_picture() {
  if (GetArenaForAllocation() == nullptr && picture_ != nullptr) {
    delete picture_;
  }
  picture_ = nullptr;
}
inline const ::io::openisms::v1::Photo& Person::_internal_picture() const {
  const ::io::openisms::v1::Photo* p = picture_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::Photo&>(
      ::io::openisms::v1::_Photo_default_instance_);
}
inline const ::io::openisms::v1::Photo& Person::picture() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Person.picture)
  return _internal_picture();
}
inline void Person::unsafe_arena_set_allocated_picture(
    ::io::openisms::v1::Photo* picture) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(picture_);
  }
  picture_ = picture;
  if (picture) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Person.picture)
}
inline ::io::openisms::v1::Photo* Person::release_picture() {
  
  ::io::openisms::v1::Photo* temp = picture_;
  picture_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::Photo* Person::unsafe_arena_release_picture() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Person.picture)
  
  ::io::openisms::v1::Photo* temp = picture_;
  picture_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::Photo* Person::_internal_mutable_picture() {
  
  if (picture_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::Photo>(GetArenaForAllocation());
    picture_ = p;
  }
  return picture_;
}
inline ::io::openisms::v1::Photo* Person::mutable_picture() {
  ::io::openisms::v1::Photo* _msg = _internal_mutable_picture();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Person.picture)
  return _msg;
}
inline void Person::set_allocated_picture(::io::openisms::v1::Photo* picture) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete picture_;
  }
  if (picture) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(picture);
    if (message_arena != submessage_arena) {
      picture = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, picture, submessage_arena);
    }
    
  } else {
    
  }
  picture_ = picture;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Person.picture)
}

// string company = 6;
inline void Person::clear_company() {
  company_.ClearToEmpty();
}
inline const std::string& Person::company() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Person.company)
  return _internal_company();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Person::set_company(ArgT0&& arg0, ArgT... args) {
 
 company_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Person.company)
}
inline std::string* Person::mutable_company() {
  std::string* _s = _internal_mutable_company();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Person.company)
  return _s;
}
inline const std::string& Person::_internal_company() const {
  return company_.Get();
}
inline void Person::_internal_set_company(const std::string& value) {
  
  company_.Set(value, GetArenaForAllocation());
}
inline std::string* Person::_internal_mutable_company() {
  
  return company_.Mutable(GetArenaForAllocation());
}
inline std::string* Person::release_company() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Person.company)
  return company_.Release();
}
inline void Person::set_allocated_company(std::string* company) {
  if (company != nullptr) {
    
  } else {
    
  }
  company_.SetAllocated(company, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (company_.IsDefault()) {
    company_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Person.company)
}

// .google.protobuf.Timestamp created = 10;
inline bool Person::_internal_has_created() const {
  return this != internal_default_instance() && created_ != nullptr;
}
inline bool Person::has_created() const {
  return _internal_has_created();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Person::_internal_created() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Person::created() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Person.created)
  return _internal_created();
}
inline void Person::unsafe_arena_set_allocated_created(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_);
  }
  created_ = created;
  if (created) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Person.created)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Person::release_created() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_;
  created_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Person::unsafe_arena_release_created() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Person.created)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_;
  created_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Person::_internal_mutable_created() {
  
  if (created_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_ = p;
  }
  return created_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Person::mutable_created() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Person.created)
  return _msg;
}
inline void Person::set_allocated_created(::PROTOBUF_NAMESPACE_ID::Timestamp* created) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_);
  }
  if (created) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created));
    if (message_arena != submessage_arena) {
      created = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created, submessage_arena);
    }
    
  } else {
    
  }
  created_ = created;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Person.created)
}

// .google.protobuf.Timestamp updated = 11;
inline bool Person::_internal_has_updated() const {
  return this != internal_default_instance() && updated_ != nullptr;
}
inline bool Person::has_updated() const {
  return _internal_has_updated();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Person::_internal_updated() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = updated_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Person::updated() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Person.updated)
  return _internal_updated();
}
inline void Person::unsafe_arena_set_allocated_updated(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_);
  }
  updated_ = updated;
  if (updated) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Person.updated)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Person::release_updated() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_;
  updated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Person::unsafe_arena_release_updated() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Person.updated)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_;
  updated_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Person::_internal_mutable_updated() {
  
  if (updated_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    updated_ = p;
  }
  return updated_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Person::mutable_updated() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Person.updated)
  return _msg;
}
inline void Person::set_allocated_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* updated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_);
  }
  if (updated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated));
    if (message_arena != submessage_arena) {
      updated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated, submessage_arena);
    }
    
  } else {
    
  }
  updated_ = updated;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Person.updated)
}

// -------------------------------------------------------------------

// Name

// string given_name = 1;
inline void Name::clear_given_name() {
  given_name_.ClearToEmpty();
}
inline const std::string& Name::given_name() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Name.given_name)
  return _internal_given_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Name::set_given_name(ArgT0&& arg0, ArgT... args) {
 
 given_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Name.given_name)
}
inline std::string* Name::mutable_given_name() {
  std::string* _s = _internal_mutable_given_name();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Name.given_name)
  return _s;
}
inline const std::string& Name::_internal_given_name() const {
  return given_name_.Get();
}
inline void Name::_internal_set_given_name(const std::string& value) {
  
  given_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Name::_internal_mutable_given_name() {
  
  return given_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Name::release_given_name() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Name.given_name)
  return given_name_.Release();
}
inline void Name::set_allocated_given_name(std::string* given_name) {
  if (given_name != nullptr) {
    
  } else {
    
  }
  given_name_.SetAllocated(given_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (given_name_.IsDefault()) {
    given_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Name.given_name)
}

// string family_name = 2;
inline void Name::clear_family_name() {
  family_name_.ClearToEmpty();
}
inline const std::string& Name::family_name() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Name.family_name)
  return _internal_family_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Name::set_family_name(ArgT0&& arg0, ArgT... args) {
 
 family_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Name.family_name)
}
inline std::string* Name::mutable_family_name() {
  std::string* _s = _internal_mutable_family_name();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Name.family_name)
  return _s;
}
inline const std::string& Name::_internal_family_name() const {
  return family_name_.Get();
}
inline void Name::_internal_set_family_name(const std::string& value) {
  
  family_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Name::_internal_mutable_family_name() {
  
  return family_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Name::release_family_name() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Name.family_name)
  return family_name_.Release();
}
inline void Name::set_allocated_family_name(std::string* family_name) {
  if (family_name != nullptr) {
    
  } else {
    
  }
  family_name_.SetAllocated(family_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (family_name_.IsDefault()) {
    family_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Name.family_name)
}

// string full_name = 3;
inline void Name::clear_full_name() {
  full_name_.ClearToEmpty();
}
inline const std::string& Name::full_name() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Name.full_name)
  return _internal_full_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Name::set_full_name(ArgT0&& arg0, ArgT... args) {
 
 full_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Name.full_name)
}
inline std::string* Name::mutable_full_name() {
  std::string* _s = _internal_mutable_full_name();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Name.full_name)
  return _s;
}
inline const std::string& Name::_internal_full_name() const {
  return full_name_.Get();
}
inline void Name::_internal_set_full_name(const std::string& value) {
  
  full_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Name::_internal_mutable_full_name() {
  
  return full_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Name::release_full_name() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Name.full_name)
  return full_name_.Release();
}
inline void Name::set_allocated_full_name(std::string* full_name) {
  if (full_name != nullptr) {
    
  } else {
    
  }
  full_name_.SetAllocated(full_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (full_name_.IsDefault()) {
    full_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Name.full_name)
}

// string title = 4;
inline void Name::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& Name::title() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Name.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Name::set_title(ArgT0&& arg0, ArgT... args) {
 
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Name.title)
}
inline std::string* Name::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Name.title)
  return _s;
}
inline const std::string& Name::_internal_title() const {
  return title_.Get();
}
inline void Name::_internal_set_title(const std::string& value) {
  
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* Name::_internal_mutable_title() {
  
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* Name::release_title() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Name.title)
  return title_.Release();
}
inline void Name::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Name.title)
}

// string position = 5;
inline void Name::clear_position() {
  position_.ClearToEmpty();
}
inline const std::string& Name::position() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Name.position)
  return _internal_position();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Name::set_position(ArgT0&& arg0, ArgT... args) {
 
 position_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Name.position)
}
inline std::string* Name::mutable_position() {
  std::string* _s = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Name.position)
  return _s;
}
inline const std::string& Name::_internal_position() const {
  return position_.Get();
}
inline void Name::_internal_set_position(const std::string& value) {
  
  position_.Set(value, GetArenaForAllocation());
}
inline std::string* Name::_internal_mutable_position() {
  
  return position_.Mutable(GetArenaForAllocation());
}
inline std::string* Name::release_position() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Name.position)
  return position_.Release();
}
inline void Name::set_allocated_position(std::string* position) {
  if (position != nullptr) {
    
  } else {
    
  }
  position_.SetAllocated(position, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (position_.IsDefault()) {
    position_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Name.position)
}

// string role = 6;
inline void Name::clear_role() {
  role_.ClearToEmpty();
}
inline const std::string& Name::role() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Name.role)
  return _internal_role();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Name::set_role(ArgT0&& arg0, ArgT... args) {
 
 role_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Name.role)
}
inline std::string* Name::mutable_role() {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Name.role)
  return _s;
}
inline const std::string& Name::_internal_role() const {
  return role_.Get();
}
inline void Name::_internal_set_role(const std::string& value) {
  
  role_.Set(value, GetArenaForAllocation());
}
inline std::string* Name::_internal_mutable_role() {
  
  return role_.Mutable(GetArenaForAllocation());
}
inline std::string* Name::release_role() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Name.role)
  return role_.Release();
}
inline void Name::set_allocated_role(std::string* role) {
  if (role != nullptr) {
    
  } else {
    
  }
  role_.SetAllocated(role, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (role_.IsDefault()) {
    role_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Name.role)
}

// -------------------------------------------------------------------

// Photo

// string url = 1;
inline void Photo::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& Photo::url() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Photo.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Photo::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Photo.url)
}
inline std::string* Photo::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Photo.url)
  return _s;
}
inline const std::string& Photo::_internal_url() const {
  return url_.Get();
}
inline void Photo::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* Photo::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* Photo::release_url() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Photo.url)
  return url_.Release();
}
inline void Photo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Photo.url)
}

// string base_64_encoded = 2;
inline void Photo::clear_base_64_encoded() {
  base_64_encoded_.ClearToEmpty();
}
inline const std::string& Photo::base_64_encoded() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Photo.base_64_encoded)
  return _internal_base_64_encoded();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Photo::set_base_64_encoded(ArgT0&& arg0, ArgT... args) {
 
 base_64_encoded_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Photo.base_64_encoded)
}
inline std::string* Photo::mutable_base_64_encoded() {
  std::string* _s = _internal_mutable_base_64_encoded();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Photo.base_64_encoded)
  return _s;
}
inline const std::string& Photo::_internal_base_64_encoded() const {
  return base_64_encoded_.Get();
}
inline void Photo::_internal_set_base_64_encoded(const std::string& value) {
  
  base_64_encoded_.Set(value, GetArenaForAllocation());
}
inline std::string* Photo::_internal_mutable_base_64_encoded() {
  
  return base_64_encoded_.Mutable(GetArenaForAllocation());
}
inline std::string* Photo::release_base_64_encoded() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Photo.base_64_encoded)
  return base_64_encoded_.Release();
}
inline void Photo::set_allocated_base_64_encoded(std::string* base_64_encoded) {
  if (base_64_encoded != nullptr) {
    
  } else {
    
  }
  base_64_encoded_.SetAllocated(base_64_encoded, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (base_64_encoded_.IsDefault()) {
    base_64_encoded_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Photo.base_64_encoded)
}

// string mime_type = 3;
inline void Photo::clear_mime_type() {
  mime_type_.ClearToEmpty();
}
inline const std::string& Photo::mime_type() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Photo.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Photo::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Photo.mime_type)
}
inline std::string* Photo::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Photo.mime_type)
  return _s;
}
inline const std::string& Photo::_internal_mime_type() const {
  return mime_type_.Get();
}
inline void Photo::_internal_set_mime_type(const std::string& value) {
  
  mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Photo::_internal_mutable_mime_type() {
  
  return mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Photo::release_mime_type() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Photo.mime_type)
  return mime_type_.Release();
}
inline void Photo::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mime_type_.IsDefault()) {
    mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Photo.mime_type)
}

// string etag = 4;
inline void Photo::clear_etag() {
  etag_.ClearToEmpty();
}
inline const std::string& Photo::etag() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Photo.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Photo::set_etag(ArgT0&& arg0, ArgT... args) {
 
 etag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Photo.etag)
}
inline std::string* Photo::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Photo.etag)
  return _s;
}
inline const std::string& Photo::_internal_etag() const {
  return etag_.Get();
}
inline void Photo::_internal_set_etag(const std::string& value) {
  
  etag_.Set(value, GetArenaForAllocation());
}
inline std::string* Photo::_internal_mutable_etag() {
  
  return etag_.Mutable(GetArenaForAllocation());
}
inline std::string* Photo::release_etag() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Photo.etag)
  return etag_.Release();
}
inline void Photo::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    
  } else {
    
  }
  etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault()) {
    etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Photo.etag)
}

// .google.protobuf.Timestamp last_modified = 5;
inline bool Photo::_internal_has_last_modified() const {
  return this != internal_default_instance() && last_modified_ != nullptr;
}
inline bool Photo::has_last_modified() const {
  return _internal_has_last_modified();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Photo::_internal_last_modified() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_modified_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Photo::last_modified() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Photo.last_modified)
  return _internal_last_modified();
}
inline void Photo::unsafe_arena_set_allocated_last_modified(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified_);
  }
  last_modified_ = last_modified;
  if (last_modified) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Photo.last_modified)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Photo::release_last_modified() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_modified_;
  last_modified_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Photo::unsafe_arena_release_last_modified() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Photo.last_modified)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_modified_;
  last_modified_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Photo::_internal_mutable_last_modified() {
  
  if (last_modified_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_modified_ = p;
  }
  return last_modified_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Photo::mutable_last_modified() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_modified();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Photo.last_modified)
  return _msg;
}
inline void Photo::set_allocated_last_modified(::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified_);
  }
  if (last_modified) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified));
    if (message_arena != submessage_arena) {
      last_modified = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_modified, submessage_arena);
    }
    
  } else {
    
  }
  last_modified_ = last_modified;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Photo.last_modified)
}

// -------------------------------------------------------------------

// Employment

// string contract = 1;
inline void Employment::clear_contract() {
  contract_.ClearToEmpty();
}
inline const std::string& Employment::contract() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Employment.contract)
  return _internal_contract();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Employment::set_contract(ArgT0&& arg0, ArgT... args) {
 
 contract_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Employment.contract)
}
inline std::string* Employment::mutable_contract() {
  std::string* _s = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Employment.contract)
  return _s;
}
inline const std::string& Employment::_internal_contract() const {
  return contract_.Get();
}
inline void Employment::_internal_set_contract(const std::string& value) {
  
  contract_.Set(value, GetArenaForAllocation());
}
inline std::string* Employment::_internal_mutable_contract() {
  
  return contract_.Mutable(GetArenaForAllocation());
}
inline std::string* Employment::release_contract() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Employment.contract)
  return contract_.Release();
}
inline void Employment::set_allocated_contract(std::string* contract) {
  if (contract != nullptr) {
    
  } else {
    
  }
  contract_.SetAllocated(contract, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_.IsDefault()) {
    contract_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Employment.contract)
}

// string status = 2;
inline void Employment::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& Employment::status() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Employment.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Employment::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Employment.status)
}
inline std::string* Employment::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Employment.status)
  return _s;
}
inline const std::string& Employment::_internal_status() const {
  return status_.Get();
}
inline void Employment::_internal_set_status(const std::string& value) {
  
  status_.Set(value, GetArenaForAllocation());
}
inline std::string* Employment::_internal_mutable_status() {
  
  return status_.Mutable(GetArenaForAllocation());
}
inline std::string* Employment::release_status() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Employment.status)
  return status_.Release();
}
inline void Employment::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault()) {
    status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Employment.status)
}

// .io.openisms.v1.Date begin = 3;
inline bool Employment::_internal_has_begin() const {
  return this != internal_default_instance() && begin_ != nullptr;
}
inline bool Employment::has_begin() const {
  return _internal_has_begin();
}
inline void Employment::clear_begin() {
  if (GetArenaForAllocation() == nullptr && begin_ != nullptr) {
    delete begin_;
  }
  begin_ = nullptr;
}
inline const ::io::openisms::v1::Date& Employment::_internal_begin() const {
  const ::io::openisms::v1::Date* p = begin_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::Date&>(
      ::io::openisms::v1::_Date_default_instance_);
}
inline const ::io::openisms::v1::Date& Employment::begin() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Employment.begin)
  return _internal_begin();
}
inline void Employment::unsafe_arena_set_allocated_begin(
    ::io::openisms::v1::Date* begin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(begin_);
  }
  begin_ = begin;
  if (begin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Employment.begin)
}
inline ::io::openisms::v1::Date* Employment::release_begin() {
  
  ::io::openisms::v1::Date* temp = begin_;
  begin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::Date* Employment::unsafe_arena_release_begin() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Employment.begin)
  
  ::io::openisms::v1::Date* temp = begin_;
  begin_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::Date* Employment::_internal_mutable_begin() {
  
  if (begin_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::Date>(GetArenaForAllocation());
    begin_ = p;
  }
  return begin_;
}
inline ::io::openisms::v1::Date* Employment::mutable_begin() {
  ::io::openisms::v1::Date* _msg = _internal_mutable_begin();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Employment.begin)
  return _msg;
}
inline void Employment::set_allocated_begin(::io::openisms::v1::Date* begin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete begin_;
  }
  if (begin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(begin);
    if (message_arena != submessage_arena) {
      begin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, begin, submessage_arena);
    }
    
  } else {
    
  }
  begin_ = begin;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Employment.begin)
}

// .io.openisms.v1.Date end = 4;
inline bool Employment::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool Employment::has_end() const {
  return _internal_has_end();
}
inline void Employment::clear_end() {
  if (GetArenaForAllocation() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
}
inline const ::io::openisms::v1::Date& Employment::_internal_end() const {
  const ::io::openisms::v1::Date* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::Date&>(
      ::io::openisms::v1::_Date_default_instance_);
}
inline const ::io::openisms::v1::Date& Employment::end() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Employment.end)
  return _internal_end();
}
inline void Employment::unsafe_arena_set_allocated_end(
    ::io::openisms::v1::Date* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Employment.end)
}
inline ::io::openisms::v1::Date* Employment::release_end() {
  
  ::io::openisms::v1::Date* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::Date* Employment::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Employment.end)
  
  ::io::openisms::v1::Date* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::Date* Employment::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::Date>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::io::openisms::v1::Date* Employment::mutable_end() {
  ::io::openisms::v1::Date* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Employment.end)
  return _msg;
}
inline void Employment::set_allocated_end(::io::openisms::v1::Date* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Employment.end)
}

// -------------------------------------------------------------------

// ConnectedAccount

// string app_id = 1;
inline void ConnectedAccount::clear_app_id() {
  app_id_.ClearToEmpty();
}
inline const std::string& ConnectedAccount::app_id() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.ConnectedAccount.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectedAccount::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.ConnectedAccount.app_id)
}
inline std::string* ConnectedAccount::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.ConnectedAccount.app_id)
  return _s;
}
inline const std::string& ConnectedAccount::_internal_app_id() const {
  return app_id_.Get();
}
inline void ConnectedAccount::_internal_set_app_id(const std::string& value) {
  
  app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectedAccount::_internal_mutable_app_id() {
  
  return app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConnectedAccount::release_app_id() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.ConnectedAccount.app_id)
  return app_id_.Release();
}
inline void ConnectedAccount::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_id_.IsDefault()) {
    app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.ConnectedAccount.app_id)
}

// string app_name = 2;
inline void ConnectedAccount::clear_app_name() {
  app_name_.ClearToEmpty();
}
inline const std::string& ConnectedAccount::app_name() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.ConnectedAccount.app_name)
  return _internal_app_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectedAccount::set_app_name(ArgT0&& arg0, ArgT... args) {
 
 app_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.ConnectedAccount.app_name)
}
inline std::string* ConnectedAccount::mutable_app_name() {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.ConnectedAccount.app_name)
  return _s;
}
inline const std::string& ConnectedAccount::_internal_app_name() const {
  return app_name_.Get();
}
inline void ConnectedAccount::_internal_set_app_name(const std::string& value) {
  
  app_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectedAccount::_internal_mutable_app_name() {
  
  return app_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConnectedAccount::release_app_name() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.ConnectedAccount.app_name)
  return app_name_.Release();
}
inline void ConnectedAccount::set_allocated_app_name(std::string* app_name) {
  if (app_name != nullptr) {
    
  } else {
    
  }
  app_name_.SetAllocated(app_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_name_.IsDefault()) {
    app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.ConnectedAccount.app_name)
}

// string app_type = 3;
inline void ConnectedAccount::clear_app_type() {
  app_type_.ClearToEmpty();
}
inline const std::string& ConnectedAccount::app_type() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.ConnectedAccount.app_type)
  return _internal_app_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectedAccount::set_app_type(ArgT0&& arg0, ArgT... args) {
 
 app_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.ConnectedAccount.app_type)
}
inline std::string* ConnectedAccount::mutable_app_type() {
  std::string* _s = _internal_mutable_app_type();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.ConnectedAccount.app_type)
  return _s;
}
inline const std::string& ConnectedAccount::_internal_app_type() const {
  return app_type_.Get();
}
inline void ConnectedAccount::_internal_set_app_type(const std::string& value) {
  
  app_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectedAccount::_internal_mutable_app_type() {
  
  return app_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ConnectedAccount::release_app_type() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.ConnectedAccount.app_type)
  return app_type_.Release();
}
inline void ConnectedAccount::set_allocated_app_type(std::string* app_type) {
  if (app_type != nullptr) {
    
  } else {
    
  }
  app_type_.SetAllocated(app_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_type_.IsDefault()) {
    app_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.ConnectedAccount.app_type)
}

// string app_url = 4;
inline void ConnectedAccount::clear_app_url() {
  app_url_.ClearToEmpty();
}
inline const std::string& ConnectedAccount::app_url() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.ConnectedAccount.app_url)
  return _internal_app_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectedAccount::set_app_url(ArgT0&& arg0, ArgT... args) {
 
 app_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.ConnectedAccount.app_url)
}
inline std::string* ConnectedAccount::mutable_app_url() {
  std::string* _s = _internal_mutable_app_url();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.ConnectedAccount.app_url)
  return _s;
}
inline const std::string& ConnectedAccount::_internal_app_url() const {
  return app_url_.Get();
}
inline void ConnectedAccount::_internal_set_app_url(const std::string& value) {
  
  app_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectedAccount::_internal_mutable_app_url() {
  
  return app_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ConnectedAccount::release_app_url() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.ConnectedAccount.app_url)
  return app_url_.Release();
}
inline void ConnectedAccount::set_allocated_app_url(std::string* app_url) {
  if (app_url != nullptr) {
    
  } else {
    
  }
  app_url_.SetAllocated(app_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_url_.IsDefault()) {
    app_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.ConnectedAccount.app_url)
}

// string user_id = 5;
inline void ConnectedAccount::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& ConnectedAccount::user_id() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.ConnectedAccount.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectedAccount::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.ConnectedAccount.user_id)
}
inline std::string* ConnectedAccount::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.ConnectedAccount.user_id)
  return _s;
}
inline const std::string& ConnectedAccount::_internal_user_id() const {
  return user_id_.Get();
}
inline void ConnectedAccount::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectedAccount::_internal_mutable_user_id() {
  
  return user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConnectedAccount::release_user_id() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.ConnectedAccount.user_id)
  return user_id_.Release();
}
inline void ConnectedAccount::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault()) {
    user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.ConnectedAccount.user_id)
}

// repeated string scopes = 6;
inline int ConnectedAccount::_internal_scopes_size() const {
  return scopes_.size();
}
inline int ConnectedAccount::scopes_size() const {
  return _internal_scopes_size();
}
inline void ConnectedAccount::clear_scopes() {
  scopes_.Clear();
}
inline std::string* ConnectedAccount::add_scopes() {
  std::string* _s = _internal_add_scopes();
  // @@protoc_insertion_point(field_add_mutable:io.openisms.v1.ConnectedAccount.scopes)
  return _s;
}
inline const std::string& ConnectedAccount::_internal_scopes(int index) const {
  return scopes_.Get(index);
}
inline const std::string& ConnectedAccount::scopes(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.ConnectedAccount.scopes)
  return _internal_scopes(index);
}
inline std::string* ConnectedAccount::mutable_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.ConnectedAccount.scopes)
  return scopes_.Mutable(index);
}
inline void ConnectedAccount::set_scopes(int index, const std::string& value) {
  scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.ConnectedAccount.scopes)
}
inline void ConnectedAccount::set_scopes(int index, std::string&& value) {
  scopes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.openisms.v1.ConnectedAccount.scopes)
}
inline void ConnectedAccount::set_scopes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.openisms.v1.ConnectedAccount.scopes)
}
inline void ConnectedAccount::set_scopes(int index, const char* value, size_t size) {
  scopes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.openisms.v1.ConnectedAccount.scopes)
}
inline std::string* ConnectedAccount::_internal_add_scopes() {
  return scopes_.Add();
}
inline void ConnectedAccount::add_scopes(const std::string& value) {
  scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.openisms.v1.ConnectedAccount.scopes)
}
inline void ConnectedAccount::add_scopes(std::string&& value) {
  scopes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.openisms.v1.ConnectedAccount.scopes)
}
inline void ConnectedAccount::add_scopes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.openisms.v1.ConnectedAccount.scopes)
}
inline void ConnectedAccount::add_scopes(const char* value, size_t size) {
  scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.openisms.v1.ConnectedAccount.scopes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConnectedAccount::scopes() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.ConnectedAccount.scopes)
  return scopes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConnectedAccount::mutable_scopes() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.ConnectedAccount.scopes)
  return &scopes_;
}

// -------------------------------------------------------------------

// PhysicalObject

// string type = 1;
inline void PhysicalObject::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& PhysicalObject::type() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhysicalObject::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.PhysicalObject.type)
}
inline std::string* PhysicalObject::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.type)
  return _s;
}
inline const std::string& PhysicalObject::_internal_type() const {
  return type_.Get();
}
inline void PhysicalObject::_internal_set_type(const std::string& value) {
  
  type_.Set(value, GetArenaForAllocation());
}
inline std::string* PhysicalObject::_internal_mutable_type() {
  
  return type_.Mutable(GetArenaForAllocation());
}
inline std::string* PhysicalObject::release_type() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.PhysicalObject.type)
  return type_.Release();
}
inline void PhysicalObject::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.PhysicalObject.type)
}

// string name = 2;
inline void PhysicalObject::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PhysicalObject::name() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhysicalObject::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.PhysicalObject.name)
}
inline std::string* PhysicalObject::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.name)
  return _s;
}
inline const std::string& PhysicalObject::_internal_name() const {
  return name_.Get();
}
inline void PhysicalObject::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* PhysicalObject::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* PhysicalObject::release_name() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.PhysicalObject.name)
  return name_.Release();
}
inline void PhysicalObject::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.PhysicalObject.name)
}

// string manufacturer = 3;
inline void PhysicalObject::clear_manufacturer() {
  manufacturer_.ClearToEmpty();
}
inline const std::string& PhysicalObject::manufacturer() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.manufacturer)
  return _internal_manufacturer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhysicalObject::set_manufacturer(ArgT0&& arg0, ArgT... args) {
 
 manufacturer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.PhysicalObject.manufacturer)
}
inline std::string* PhysicalObject::mutable_manufacturer() {
  std::string* _s = _internal_mutable_manufacturer();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.manufacturer)
  return _s;
}
inline const std::string& PhysicalObject::_internal_manufacturer() const {
  return manufacturer_.Get();
}
inline void PhysicalObject::_internal_set_manufacturer(const std::string& value) {
  
  manufacturer_.Set(value, GetArenaForAllocation());
}
inline std::string* PhysicalObject::_internal_mutable_manufacturer() {
  
  return manufacturer_.Mutable(GetArenaForAllocation());
}
inline std::string* PhysicalObject::release_manufacturer() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.PhysicalObject.manufacturer)
  return manufacturer_.Release();
}
inline void PhysicalObject::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    
  } else {
    
  }
  manufacturer_.SetAllocated(manufacturer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (manufacturer_.IsDefault()) {
    manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.PhysicalObject.manufacturer)
}

// string vendor = 4;
inline void PhysicalObject::clear_vendor() {
  vendor_.ClearToEmpty();
}
inline const std::string& PhysicalObject::vendor() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhysicalObject::set_vendor(ArgT0&& arg0, ArgT... args) {
 
 vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.PhysicalObject.vendor)
}
inline std::string* PhysicalObject::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.vendor)
  return _s;
}
inline const std::string& PhysicalObject::_internal_vendor() const {
  return vendor_.Get();
}
inline void PhysicalObject::_internal_set_vendor(const std::string& value) {
  
  vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* PhysicalObject::_internal_mutable_vendor() {
  
  return vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* PhysicalObject::release_vendor() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.PhysicalObject.vendor)
  return vendor_.Release();
}
inline void PhysicalObject::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    
  } else {
    
  }
  vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vendor_.IsDefault()) {
    vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.PhysicalObject.vendor)
}

// string identifier = 5;
inline void PhysicalObject::clear_identifier() {
  identifier_.ClearToEmpty();
}
inline const std::string& PhysicalObject::identifier() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhysicalObject::set_identifier(ArgT0&& arg0, ArgT... args) {
 
 identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.PhysicalObject.identifier)
}
inline std::string* PhysicalObject::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.identifier)
  return _s;
}
inline const std::string& PhysicalObject::_internal_identifier() const {
  return identifier_.Get();
}
inline void PhysicalObject::_internal_set_identifier(const std::string& value) {
  
  identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* PhysicalObject::_internal_mutable_identifier() {
  
  return identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* PhysicalObject::release_identifier() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.PhysicalObject.identifier)
  return identifier_.Release();
}
inline void PhysicalObject::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    
  } else {
    
  }
  identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.PhysicalObject.identifier)
}

// string serial_number = 6;
inline void PhysicalObject::clear_serial_number() {
  serial_number_.ClearToEmpty();
}
inline const std::string& PhysicalObject::serial_number() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhysicalObject::set_serial_number(ArgT0&& arg0, ArgT... args) {
 
 serial_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.PhysicalObject.serial_number)
}
inline std::string* PhysicalObject::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.serial_number)
  return _s;
}
inline const std::string& PhysicalObject::_internal_serial_number() const {
  return serial_number_.Get();
}
inline void PhysicalObject::_internal_set_serial_number(const std::string& value) {
  
  serial_number_.Set(value, GetArenaForAllocation());
}
inline std::string* PhysicalObject::_internal_mutable_serial_number() {
  
  return serial_number_.Mutable(GetArenaForAllocation());
}
inline std::string* PhysicalObject::release_serial_number() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.PhysicalObject.serial_number)
  return serial_number_.Release();
}
inline void PhysicalObject::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    
  } else {
    
  }
  serial_number_.SetAllocated(serial_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_number_.IsDefault()) {
    serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.PhysicalObject.serial_number)
}

// string imei = 7;
inline void PhysicalObject::clear_imei() {
  imei_.ClearToEmpty();
}
inline const std::string& PhysicalObject::imei() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.imei)
  return _internal_imei();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhysicalObject::set_imei(ArgT0&& arg0, ArgT... args) {
 
 imei_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.PhysicalObject.imei)
}
inline std::string* PhysicalObject::mutable_imei() {
  std::string* _s = _internal_mutable_imei();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.imei)
  return _s;
}
inline const std::string& PhysicalObject::_internal_imei() const {
  return imei_.Get();
}
inline void PhysicalObject::_internal_set_imei(const std::string& value) {
  
  imei_.Set(value, GetArenaForAllocation());
}
inline std::string* PhysicalObject::_internal_mutable_imei() {
  
  return imei_.Mutable(GetArenaForAllocation());
}
inline std::string* PhysicalObject::release_imei() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.PhysicalObject.imei)
  return imei_.Release();
}
inline void PhysicalObject::set_allocated_imei(std::string* imei) {
  if (imei != nullptr) {
    
  } else {
    
  }
  imei_.SetAllocated(imei, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (imei_.IsDefault()) {
    imei_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.PhysicalObject.imei)
}

// string meid = 8;
inline void PhysicalObject::clear_meid() {
  meid_.ClearToEmpty();
}
inline const std::string& PhysicalObject::meid() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.meid)
  return _internal_meid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhysicalObject::set_meid(ArgT0&& arg0, ArgT... args) {
 
 meid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.PhysicalObject.meid)
}
inline std::string* PhysicalObject::mutable_meid() {
  std::string* _s = _internal_mutable_meid();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.meid)
  return _s;
}
inline const std::string& PhysicalObject::_internal_meid() const {
  return meid_.Get();
}
inline void PhysicalObject::_internal_set_meid(const std::string& value) {
  
  meid_.Set(value, GetArenaForAllocation());
}
inline std::string* PhysicalObject::_internal_mutable_meid() {
  
  return meid_.Mutable(GetArenaForAllocation());
}
inline std::string* PhysicalObject::release_meid() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.PhysicalObject.meid)
  return meid_.Release();
}
inline void PhysicalObject::set_allocated_meid(std::string* meid) {
  if (meid != nullptr) {
    
  } else {
    
  }
  meid_.SetAllocated(meid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (meid_.IsDefault()) {
    meid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.PhysicalObject.meid)
}

// repeated .io.openisms.v1.Network networks = 9;
inline int PhysicalObject::_internal_networks_size() const {
  return networks_.size();
}
inline int PhysicalObject::networks_size() const {
  return _internal_networks_size();
}
inline void PhysicalObject::clear_networks() {
  networks_.Clear();
}
inline ::io::openisms::v1::Network* PhysicalObject::mutable_networks(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.networks)
  return networks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Network >*
PhysicalObject::mutable_networks() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.PhysicalObject.networks)
  return &networks_;
}
inline const ::io::openisms::v1::Network& PhysicalObject::_internal_networks(int index) const {
  return networks_.Get(index);
}
inline const ::io::openisms::v1::Network& PhysicalObject::networks(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.networks)
  return _internal_networks(index);
}
inline ::io::openisms::v1::Network* PhysicalObject::_internal_add_networks() {
  return networks_.Add();
}
inline ::io::openisms::v1::Network* PhysicalObject::add_networks() {
  ::io::openisms::v1::Network* _add = _internal_add_networks();
  // @@protoc_insertion_point(field_add:io.openisms.v1.PhysicalObject.networks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Network >&
PhysicalObject::networks() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.PhysicalObject.networks)
  return networks_;
}

// string hostname = 10;
inline void PhysicalObject::clear_hostname() {
  hostname_.ClearToEmpty();
}
inline const std::string& PhysicalObject::hostname() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhysicalObject::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.PhysicalObject.hostname)
}
inline std::string* PhysicalObject::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.hostname)
  return _s;
}
inline const std::string& PhysicalObject::_internal_hostname() const {
  return hostname_.Get();
}
inline void PhysicalObject::_internal_set_hostname(const std::string& value) {
  
  hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* PhysicalObject::_internal_mutable_hostname() {
  
  return hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* PhysicalObject::release_hostname() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.PhysicalObject.hostname)
  return hostname_.Release();
}
inline void PhysicalObject::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hostname_.IsDefault()) {
    hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.PhysicalObject.hostname)
}

// repeated string user_accounts = 11;
inline int PhysicalObject::_internal_user_accounts_size() const {
  return user_accounts_.size();
}
inline int PhysicalObject::user_accounts_size() const {
  return _internal_user_accounts_size();
}
inline void PhysicalObject::clear_user_accounts() {
  user_accounts_.Clear();
}
inline std::string* PhysicalObject::add_user_accounts() {
  std::string* _s = _internal_add_user_accounts();
  // @@protoc_insertion_point(field_add_mutable:io.openisms.v1.PhysicalObject.user_accounts)
  return _s;
}
inline const std::string& PhysicalObject::_internal_user_accounts(int index) const {
  return user_accounts_.Get(index);
}
inline const std::string& PhysicalObject::user_accounts(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.user_accounts)
  return _internal_user_accounts(index);
}
inline std::string* PhysicalObject::mutable_user_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.user_accounts)
  return user_accounts_.Mutable(index);
}
inline void PhysicalObject::set_user_accounts(int index, const std::string& value) {
  user_accounts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.PhysicalObject.user_accounts)
}
inline void PhysicalObject::set_user_accounts(int index, std::string&& value) {
  user_accounts_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.openisms.v1.PhysicalObject.user_accounts)
}
inline void PhysicalObject::set_user_accounts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  user_accounts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.openisms.v1.PhysicalObject.user_accounts)
}
inline void PhysicalObject::set_user_accounts(int index, const char* value, size_t size) {
  user_accounts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.openisms.v1.PhysicalObject.user_accounts)
}
inline std::string* PhysicalObject::_internal_add_user_accounts() {
  return user_accounts_.Add();
}
inline void PhysicalObject::add_user_accounts(const std::string& value) {
  user_accounts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.openisms.v1.PhysicalObject.user_accounts)
}
inline void PhysicalObject::add_user_accounts(std::string&& value) {
  user_accounts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.openisms.v1.PhysicalObject.user_accounts)
}
inline void PhysicalObject::add_user_accounts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  user_accounts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.openisms.v1.PhysicalObject.user_accounts)
}
inline void PhysicalObject::add_user_accounts(const char* value, size_t size) {
  user_accounts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.openisms.v1.PhysicalObject.user_accounts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PhysicalObject::user_accounts() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.PhysicalObject.user_accounts)
  return user_accounts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PhysicalObject::mutable_user_accounts() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.PhysicalObject.user_accounts)
  return &user_accounts_;
}

// .io.openisms.v1.OperatingSystem os = 12;
inline bool PhysicalObject::_internal_has_os() const {
  return this != internal_default_instance() && os_ != nullptr;
}
inline bool PhysicalObject::has_os() const {
  return _internal_has_os();
}
inline void PhysicalObject::clear_os() {
  if (GetArenaForAllocation() == nullptr && os_ != nullptr) {
    delete os_;
  }
  os_ = nullptr;
}
inline const ::io::openisms::v1::OperatingSystem& PhysicalObject::_internal_os() const {
  const ::io::openisms::v1::OperatingSystem* p = os_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::OperatingSystem&>(
      ::io::openisms::v1::_OperatingSystem_default_instance_);
}
inline const ::io::openisms::v1::OperatingSystem& PhysicalObject::os() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.os)
  return _internal_os();
}
inline void PhysicalObject::unsafe_arena_set_allocated_os(
    ::io::openisms::v1::OperatingSystem* os) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(os_);
  }
  os_ = os;
  if (os) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.PhysicalObject.os)
}
inline ::io::openisms::v1::OperatingSystem* PhysicalObject::release_os() {
  
  ::io::openisms::v1::OperatingSystem* temp = os_;
  os_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::OperatingSystem* PhysicalObject::unsafe_arena_release_os() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.PhysicalObject.os)
  
  ::io::openisms::v1::OperatingSystem* temp = os_;
  os_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::OperatingSystem* PhysicalObject::_internal_mutable_os() {
  
  if (os_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::OperatingSystem>(GetArenaForAllocation());
    os_ = p;
  }
  return os_;
}
inline ::io::openisms::v1::OperatingSystem* PhysicalObject::mutable_os() {
  ::io::openisms::v1::OperatingSystem* _msg = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.os)
  return _msg;
}
inline void PhysicalObject::set_allocated_os(::io::openisms::v1::OperatingSystem* os) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete os_;
  }
  if (os) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(os);
    if (message_arena != submessage_arena) {
      os = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, os, submessage_arena);
    }
    
  } else {
    
  }
  os_ = os;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.PhysicalObject.os)
}

// .io.openisms.v1.SecurityFeatures security = 13;
inline bool PhysicalObject::_internal_has_security() const {
  return this != internal_default_instance() && security_ != nullptr;
}
inline bool PhysicalObject::has_security() const {
  return _internal_has_security();
}
inline void PhysicalObject::clear_security() {
  if (GetArenaForAllocation() == nullptr && security_ != nullptr) {
    delete security_;
  }
  security_ = nullptr;
}
inline const ::io::openisms::v1::SecurityFeatures& PhysicalObject::_internal_security() const {
  const ::io::openisms::v1::SecurityFeatures* p = security_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::SecurityFeatures&>(
      ::io::openisms::v1::_SecurityFeatures_default_instance_);
}
inline const ::io::openisms::v1::SecurityFeatures& PhysicalObject::security() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.security)
  return _internal_security();
}
inline void PhysicalObject::unsafe_arena_set_allocated_security(
    ::io::openisms::v1::SecurityFeatures* security) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(security_);
  }
  security_ = security;
  if (security) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.PhysicalObject.security)
}
inline ::io::openisms::v1::SecurityFeatures* PhysicalObject::release_security() {
  
  ::io::openisms::v1::SecurityFeatures* temp = security_;
  security_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::SecurityFeatures* PhysicalObject::unsafe_arena_release_security() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.PhysicalObject.security)
  
  ::io::openisms::v1::SecurityFeatures* temp = security_;
  security_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::SecurityFeatures* PhysicalObject::_internal_mutable_security() {
  
  if (security_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::SecurityFeatures>(GetArenaForAllocation());
    security_ = p;
  }
  return security_;
}
inline ::io::openisms::v1::SecurityFeatures* PhysicalObject::mutable_security() {
  ::io::openisms::v1::SecurityFeatures* _msg = _internal_mutable_security();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.security)
  return _msg;
}
inline void PhysicalObject::set_allocated_security(::io::openisms::v1::SecurityFeatures* security) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete security_;
  }
  if (security) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(security);
    if (message_arena != submessage_arena) {
      security = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, security, submessage_arena);
    }
    
  } else {
    
  }
  security_ = security;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.PhysicalObject.security)
}

// repeated .io.openisms.v1.Profile profiles = 14;
inline int PhysicalObject::_internal_profiles_size() const {
  return profiles_.size();
}
inline int PhysicalObject::profiles_size() const {
  return _internal_profiles_size();
}
inline void PhysicalObject::clear_profiles() {
  profiles_.Clear();
}
inline ::io::openisms::v1::Profile* PhysicalObject::mutable_profiles(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.profiles)
  return profiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Profile >*
PhysicalObject::mutable_profiles() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.PhysicalObject.profiles)
  return &profiles_;
}
inline const ::io::openisms::v1::Profile& PhysicalObject::_internal_profiles(int index) const {
  return profiles_.Get(index);
}
inline const ::io::openisms::v1::Profile& PhysicalObject::profiles(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.profiles)
  return _internal_profiles(index);
}
inline ::io::openisms::v1::Profile* PhysicalObject::_internal_add_profiles() {
  return profiles_.Add();
}
inline ::io::openisms::v1::Profile* PhysicalObject::add_profiles() {
  ::io::openisms::v1::Profile* _add = _internal_add_profiles();
  // @@protoc_insertion_point(field_add:io.openisms.v1.PhysicalObject.profiles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Profile >&
PhysicalObject::profiles() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.PhysicalObject.profiles)
  return profiles_;
}

// repeated .io.openisms.v1.Application apps = 15;
inline int PhysicalObject::_internal_apps_size() const {
  return apps_.size();
}
inline int PhysicalObject::apps_size() const {
  return _internal_apps_size();
}
inline void PhysicalObject::clear_apps() {
  apps_.Clear();
}
inline ::io::openisms::v1::Application* PhysicalObject::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.apps)
  return apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Application >*
PhysicalObject::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.PhysicalObject.apps)
  return &apps_;
}
inline const ::io::openisms::v1::Application& PhysicalObject::_internal_apps(int index) const {
  return apps_.Get(index);
}
inline const ::io::openisms::v1::Application& PhysicalObject::apps(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.apps)
  return _internal_apps(index);
}
inline ::io::openisms::v1::Application* PhysicalObject::_internal_add_apps() {
  return apps_.Add();
}
inline ::io::openisms::v1::Application* PhysicalObject::add_apps() {
  ::io::openisms::v1::Application* _add = _internal_add_apps();
  // @@protoc_insertion_point(field_add:io.openisms.v1.PhysicalObject.apps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Application >&
PhysicalObject::apps() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.PhysicalObject.apps)
  return apps_;
}

// repeated string tags = 20;
inline int PhysicalObject::_internal_tags_size() const {
  return tags_.size();
}
inline int PhysicalObject::tags_size() const {
  return _internal_tags_size();
}
inline void PhysicalObject::clear_tags() {
  tags_.Clear();
}
inline std::string* PhysicalObject::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:io.openisms.v1.PhysicalObject.tags)
  return _s;
}
inline const std::string& PhysicalObject::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& PhysicalObject::tags(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.PhysicalObject.tags)
  return _internal_tags(index);
}
inline std::string* PhysicalObject::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.PhysicalObject.tags)
  return tags_.Mutable(index);
}
inline void PhysicalObject::set_tags(int index, const std::string& value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.PhysicalObject.tags)
}
inline void PhysicalObject::set_tags(int index, std::string&& value) {
  tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.openisms.v1.PhysicalObject.tags)
}
inline void PhysicalObject::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.openisms.v1.PhysicalObject.tags)
}
inline void PhysicalObject::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.openisms.v1.PhysicalObject.tags)
}
inline std::string* PhysicalObject::_internal_add_tags() {
  return tags_.Add();
}
inline void PhysicalObject::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.openisms.v1.PhysicalObject.tags)
}
inline void PhysicalObject::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.openisms.v1.PhysicalObject.tags)
}
inline void PhysicalObject::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.openisms.v1.PhysicalObject.tags)
}
inline void PhysicalObject::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.openisms.v1.PhysicalObject.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PhysicalObject::tags() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.PhysicalObject.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PhysicalObject::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.PhysicalObject.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// SecurityFeatures

// .google.protobuf.BoolValue activation_lock = 1;
inline bool SecurityFeatures::_internal_has_activation_lock() const {
  return this != internal_default_instance() && activation_lock_ != nullptr;
}
inline bool SecurityFeatures::has_activation_lock() const {
  return _internal_has_activation_lock();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::_internal_activation_lock() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = activation_lock_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::activation_lock() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SecurityFeatures.activation_lock)
  return _internal_activation_lock();
}
inline void SecurityFeatures::unsafe_arena_set_allocated_activation_lock(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* activation_lock) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(activation_lock_);
  }
  activation_lock_ = activation_lock;
  if (activation_lock) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.SecurityFeatures.activation_lock)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::release_activation_lock() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = activation_lock_;
  activation_lock_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::unsafe_arena_release_activation_lock() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.SecurityFeatures.activation_lock)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = activation_lock_;
  activation_lock_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::_internal_mutable_activation_lock() {
  
  if (activation_lock_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    activation_lock_ = p;
  }
  return activation_lock_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::mutable_activation_lock() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_activation_lock();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.SecurityFeatures.activation_lock)
  return _msg;
}
inline void SecurityFeatures::set_allocated_activation_lock(::PROTOBUF_NAMESPACE_ID::BoolValue* activation_lock) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(activation_lock_);
  }
  if (activation_lock) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(activation_lock));
    if (message_arena != submessage_arena) {
      activation_lock = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation_lock, submessage_arena);
    }
    
  } else {
    
  }
  activation_lock_ = activation_lock;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.SecurityFeatures.activation_lock)
}

// .google.protobuf.BoolValue supervised = 2;
inline bool SecurityFeatures::_internal_has_supervised() const {
  return this != internal_default_instance() && supervised_ != nullptr;
}
inline bool SecurityFeatures::has_supervised() const {
  return _internal_has_supervised();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::_internal_supervised() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = supervised_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::supervised() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SecurityFeatures.supervised)
  return _internal_supervised();
}
inline void SecurityFeatures::unsafe_arena_set_allocated_supervised(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* supervised) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(supervised_);
  }
  supervised_ = supervised;
  if (supervised) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.SecurityFeatures.supervised)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::release_supervised() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = supervised_;
  supervised_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::unsafe_arena_release_supervised() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.SecurityFeatures.supervised)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = supervised_;
  supervised_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::_internal_mutable_supervised() {
  
  if (supervised_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    supervised_ = p;
  }
  return supervised_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::mutable_supervised() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_supervised();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.SecurityFeatures.supervised)
  return _msg;
}
inline void SecurityFeatures::set_allocated_supervised(::PROTOBUF_NAMESPACE_ID::BoolValue* supervised) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(supervised_);
  }
  if (supervised) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(supervised));
    if (message_arena != submessage_arena) {
      supervised = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supervised, submessage_arena);
    }
    
  } else {
    
  }
  supervised_ = supervised;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.SecurityFeatures.supervised)
}

// .google.protobuf.BoolValue file_vault = 3;
inline bool SecurityFeatures::_internal_has_file_vault() const {
  return this != internal_default_instance() && file_vault_ != nullptr;
}
inline bool SecurityFeatures::has_file_vault() const {
  return _internal_has_file_vault();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::_internal_file_vault() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = file_vault_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::file_vault() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SecurityFeatures.file_vault)
  return _internal_file_vault();
}
inline void SecurityFeatures::unsafe_arena_set_allocated_file_vault(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* file_vault) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(file_vault_);
  }
  file_vault_ = file_vault;
  if (file_vault) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.SecurityFeatures.file_vault)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::release_file_vault() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = file_vault_;
  file_vault_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::unsafe_arena_release_file_vault() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.SecurityFeatures.file_vault)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = file_vault_;
  file_vault_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::_internal_mutable_file_vault() {
  
  if (file_vault_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    file_vault_ = p;
  }
  return file_vault_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::mutable_file_vault() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_file_vault();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.SecurityFeatures.file_vault)
  return _msg;
}
inline void SecurityFeatures::set_allocated_file_vault(::PROTOBUF_NAMESPACE_ID::BoolValue* file_vault) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(file_vault_);
  }
  if (file_vault) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(file_vault));
    if (message_arena != submessage_arena) {
      file_vault = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file_vault, submessage_arena);
    }
    
  } else {
    
  }
  file_vault_ = file_vault;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.SecurityFeatures.file_vault)
}

// .google.protobuf.BoolValue full_disk_encryption = 4;
inline bool SecurityFeatures::_internal_has_full_disk_encryption() const {
  return this != internal_default_instance() && full_disk_encryption_ != nullptr;
}
inline bool SecurityFeatures::has_full_disk_encryption() const {
  return _internal_has_full_disk_encryption();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::_internal_full_disk_encryption() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = full_disk_encryption_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::full_disk_encryption() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SecurityFeatures.full_disk_encryption)
  return _internal_full_disk_encryption();
}
inline void SecurityFeatures::unsafe_arena_set_allocated_full_disk_encryption(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* full_disk_encryption) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_disk_encryption_);
  }
  full_disk_encryption_ = full_disk_encryption;
  if (full_disk_encryption) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.SecurityFeatures.full_disk_encryption)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::release_full_disk_encryption() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = full_disk_encryption_;
  full_disk_encryption_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::unsafe_arena_release_full_disk_encryption() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.SecurityFeatures.full_disk_encryption)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = full_disk_encryption_;
  full_disk_encryption_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::_internal_mutable_full_disk_encryption() {
  
  if (full_disk_encryption_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    full_disk_encryption_ = p;
  }
  return full_disk_encryption_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::mutable_full_disk_encryption() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_full_disk_encryption();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.SecurityFeatures.full_disk_encryption)
  return _msg;
}
inline void SecurityFeatures::set_allocated_full_disk_encryption(::PROTOBUF_NAMESPACE_ID::BoolValue* full_disk_encryption) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_disk_encryption_);
  }
  if (full_disk_encryption) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_disk_encryption));
    if (message_arena != submessage_arena) {
      full_disk_encryption = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, full_disk_encryption, submessage_arena);
    }
    
  } else {
    
  }
  full_disk_encryption_ = full_disk_encryption;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.SecurityFeatures.full_disk_encryption)
}

// .google.protobuf.BoolValue secure_password = 5;
inline bool SecurityFeatures::_internal_has_secure_password() const {
  return this != internal_default_instance() && secure_password_ != nullptr;
}
inline bool SecurityFeatures::has_secure_password() const {
  return _internal_has_secure_password();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::_internal_secure_password() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = secure_password_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::secure_password() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SecurityFeatures.secure_password)
  return _internal_secure_password();
}
inline void SecurityFeatures::unsafe_arena_set_allocated_secure_password(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* secure_password) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(secure_password_);
  }
  secure_password_ = secure_password;
  if (secure_password) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.SecurityFeatures.secure_password)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::release_secure_password() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = secure_password_;
  secure_password_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::unsafe_arena_release_secure_password() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.SecurityFeatures.secure_password)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = secure_password_;
  secure_password_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::_internal_mutable_secure_password() {
  
  if (secure_password_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    secure_password_ = p;
  }
  return secure_password_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::mutable_secure_password() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_secure_password();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.SecurityFeatures.secure_password)
  return _msg;
}
inline void SecurityFeatures::set_allocated_secure_password(::PROTOBUF_NAMESPACE_ID::BoolValue* secure_password) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(secure_password_);
  }
  if (secure_password) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(secure_password));
    if (message_arena != submessage_arena) {
      secure_password = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, secure_password, submessage_arena);
    }
    
  } else {
    
  }
  secure_password_ = secure_password;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.SecurityFeatures.secure_password)
}

// .google.protobuf.BoolValue automatic_screen_lock = 6;
inline bool SecurityFeatures::_internal_has_automatic_screen_lock() const {
  return this != internal_default_instance() && automatic_screen_lock_ != nullptr;
}
inline bool SecurityFeatures::has_automatic_screen_lock() const {
  return _internal_has_automatic_screen_lock();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::_internal_automatic_screen_lock() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = automatic_screen_lock_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::automatic_screen_lock() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SecurityFeatures.automatic_screen_lock)
  return _internal_automatic_screen_lock();
}
inline void SecurityFeatures::unsafe_arena_set_allocated_automatic_screen_lock(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* automatic_screen_lock) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(automatic_screen_lock_);
  }
  automatic_screen_lock_ = automatic_screen_lock;
  if (automatic_screen_lock) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.SecurityFeatures.automatic_screen_lock)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::release_automatic_screen_lock() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = automatic_screen_lock_;
  automatic_screen_lock_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::unsafe_arena_release_automatic_screen_lock() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.SecurityFeatures.automatic_screen_lock)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = automatic_screen_lock_;
  automatic_screen_lock_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::_internal_mutable_automatic_screen_lock() {
  
  if (automatic_screen_lock_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    automatic_screen_lock_ = p;
  }
  return automatic_screen_lock_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::mutable_automatic_screen_lock() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_automatic_screen_lock();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.SecurityFeatures.automatic_screen_lock)
  return _msg;
}
inline void SecurityFeatures::set_allocated_automatic_screen_lock(::PROTOBUF_NAMESPACE_ID::BoolValue* automatic_screen_lock) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(automatic_screen_lock_);
  }
  if (automatic_screen_lock) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(automatic_screen_lock));
    if (message_arena != submessage_arena) {
      automatic_screen_lock = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, automatic_screen_lock, submessage_arena);
    }
    
  } else {
    
  }
  automatic_screen_lock_ = automatic_screen_lock;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.SecurityFeatures.automatic_screen_lock)
}

// .google.protobuf.Int32Value screen_lock_after = 7;
inline bool SecurityFeatures::_internal_has_screen_lock_after() const {
  return this != internal_default_instance() && screen_lock_after_ != nullptr;
}
inline bool SecurityFeatures::has_screen_lock_after() const {
  return _internal_has_screen_lock_after();
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& SecurityFeatures::_internal_screen_lock_after() const {
  const ::PROTOBUF_NAMESPACE_ID::Int32Value* p = screen_lock_after_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Int32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Int32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& SecurityFeatures::screen_lock_after() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SecurityFeatures.screen_lock_after)
  return _internal_screen_lock_after();
}
inline void SecurityFeatures::unsafe_arena_set_allocated_screen_lock_after(
    ::PROTOBUF_NAMESPACE_ID::Int32Value* screen_lock_after) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(screen_lock_after_);
  }
  screen_lock_after_ = screen_lock_after;
  if (screen_lock_after) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.SecurityFeatures.screen_lock_after)
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* SecurityFeatures::release_screen_lock_after() {
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = screen_lock_after_;
  screen_lock_after_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* SecurityFeatures::unsafe_arena_release_screen_lock_after() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.SecurityFeatures.screen_lock_after)
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = screen_lock_after_;
  screen_lock_after_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* SecurityFeatures::_internal_mutable_screen_lock_after() {
  
  if (screen_lock_after_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Int32Value>(GetArenaForAllocation());
    screen_lock_after_ = p;
  }
  return screen_lock_after_;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* SecurityFeatures::mutable_screen_lock_after() {
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _msg = _internal_mutable_screen_lock_after();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.SecurityFeatures.screen_lock_after)
  return _msg;
}
inline void SecurityFeatures::set_allocated_screen_lock_after(::PROTOBUF_NAMESPACE_ID::Int32Value* screen_lock_after) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(screen_lock_after_);
  }
  if (screen_lock_after) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(screen_lock_after));
    if (message_arena != submessage_arena) {
      screen_lock_after = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, screen_lock_after, submessage_arena);
    }
    
  } else {
    
  }
  screen_lock_after_ = screen_lock_after;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.SecurityFeatures.screen_lock_after)
}

// .google.protobuf.BoolValue firewall_enabled = 8;
inline bool SecurityFeatures::_internal_has_firewall_enabled() const {
  return this != internal_default_instance() && firewall_enabled_ != nullptr;
}
inline bool SecurityFeatures::has_firewall_enabled() const {
  return _internal_has_firewall_enabled();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::_internal_firewall_enabled() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = firewall_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::firewall_enabled() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SecurityFeatures.firewall_enabled)
  return _internal_firewall_enabled();
}
inline void SecurityFeatures::unsafe_arena_set_allocated_firewall_enabled(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* firewall_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(firewall_enabled_);
  }
  firewall_enabled_ = firewall_enabled;
  if (firewall_enabled) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.SecurityFeatures.firewall_enabled)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::release_firewall_enabled() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = firewall_enabled_;
  firewall_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::unsafe_arena_release_firewall_enabled() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.SecurityFeatures.firewall_enabled)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = firewall_enabled_;
  firewall_enabled_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::_internal_mutable_firewall_enabled() {
  
  if (firewall_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    firewall_enabled_ = p;
  }
  return firewall_enabled_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::mutable_firewall_enabled() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_firewall_enabled();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.SecurityFeatures.firewall_enabled)
  return _msg;
}
inline void SecurityFeatures::set_allocated_firewall_enabled(::PROTOBUF_NAMESPACE_ID::BoolValue* firewall_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(firewall_enabled_);
  }
  if (firewall_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(firewall_enabled));
    if (message_arena != submessage_arena) {
      firewall_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, firewall_enabled, submessage_arena);
    }
    
  } else {
    
  }
  firewall_enabled_ = firewall_enabled;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.SecurityFeatures.firewall_enabled)
}

// .google.protobuf.BoolValue automatic_updates = 9;
inline bool SecurityFeatures::_internal_has_automatic_updates() const {
  return this != internal_default_instance() && automatic_updates_ != nullptr;
}
inline bool SecurityFeatures::has_automatic_updates() const {
  return _internal_has_automatic_updates();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::_internal_automatic_updates() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = automatic_updates_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SecurityFeatures::automatic_updates() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.SecurityFeatures.automatic_updates)
  return _internal_automatic_updates();
}
inline void SecurityFeatures::unsafe_arena_set_allocated_automatic_updates(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* automatic_updates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(automatic_updates_);
  }
  automatic_updates_ = automatic_updates;
  if (automatic_updates) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.SecurityFeatures.automatic_updates)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::release_automatic_updates() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = automatic_updates_;
  automatic_updates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::unsafe_arena_release_automatic_updates() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.SecurityFeatures.automatic_updates)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = automatic_updates_;
  automatic_updates_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::_internal_mutable_automatic_updates() {
  
  if (automatic_updates_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    automatic_updates_ = p;
  }
  return automatic_updates_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SecurityFeatures::mutable_automatic_updates() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_automatic_updates();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.SecurityFeatures.automatic_updates)
  return _msg;
}
inline void SecurityFeatures::set_allocated_automatic_updates(::PROTOBUF_NAMESPACE_ID::BoolValue* automatic_updates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(automatic_updates_);
  }
  if (automatic_updates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(automatic_updates));
    if (message_arena != submessage_arena) {
      automatic_updates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, automatic_updates, submessage_arena);
    }
    
  } else {
    
  }
  automatic_updates_ = automatic_updates;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.SecurityFeatures.automatic_updates)
}

// -------------------------------------------------------------------

// Network

// string name = 1;
inline void Network::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Network::name() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Network.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Network::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Network.name)
}
inline std::string* Network::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Network.name)
  return _s;
}
inline const std::string& Network::_internal_name() const {
  return name_.Get();
}
inline void Network::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Network::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Network::release_name() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Network.name)
  return name_.Release();
}
inline void Network::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Network.name)
}

// string type = 2;
inline void Network::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Network::type() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Network.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Network::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Network.type)
}
inline std::string* Network::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Network.type)
  return _s;
}
inline const std::string& Network::_internal_type() const {
  return type_.Get();
}
inline void Network::_internal_set_type(const std::string& value) {
  
  type_.Set(value, GetArenaForAllocation());
}
inline std::string* Network::_internal_mutable_type() {
  
  return type_.Mutable(GetArenaForAllocation());
}
inline std::string* Network::release_type() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Network.type)
  return type_.Release();
}
inline void Network::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Network.type)
}

// string mac_address = 3;
inline void Network::clear_mac_address() {
  mac_address_.ClearToEmpty();
}
inline const std::string& Network::mac_address() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Network.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Network::set_mac_address(ArgT0&& arg0, ArgT... args) {
 
 mac_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Network.mac_address)
}
inline std::string* Network::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Network.mac_address)
  return _s;
}
inline const std::string& Network::_internal_mac_address() const {
  return mac_address_.Get();
}
inline void Network::_internal_set_mac_address(const std::string& value) {
  
  mac_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Network::_internal_mutable_mac_address() {
  
  return mac_address_.Mutable(GetArenaForAllocation());
}
inline std::string* Network::release_mac_address() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Network.mac_address)
  return mac_address_.Release();
}
inline void Network::set_allocated_mac_address(std::string* mac_address) {
  if (mac_address != nullptr) {
    
  } else {
    
  }
  mac_address_.SetAllocated(mac_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_address_.IsDefault()) {
    mac_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Network.mac_address)
}

// -------------------------------------------------------------------

// OperatingSystem

// .io.openisms.v1.OperatingSystem.OperatingSystems os = 1;
inline void OperatingSystem::clear_os() {
  os_ = 0;
}
inline ::io::openisms::v1::OperatingSystem_OperatingSystems OperatingSystem::_internal_os() const {
  return static_cast< ::io::openisms::v1::OperatingSystem_OperatingSystems >(os_);
}
inline ::io::openisms::v1::OperatingSystem_OperatingSystems OperatingSystem::os() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.OperatingSystem.os)
  return _internal_os();
}
inline void OperatingSystem::_internal_set_os(::io::openisms::v1::OperatingSystem_OperatingSystems value) {
  
  os_ = value;
}
inline void OperatingSystem::set_os(::io::openisms::v1::OperatingSystem_OperatingSystems value) {
  _internal_set_os(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.OperatingSystem.os)
}

// string major_version = 2;
inline void OperatingSystem::clear_major_version() {
  major_version_.ClearToEmpty();
}
inline const std::string& OperatingSystem::major_version() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.OperatingSystem.major_version)
  return _internal_major_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperatingSystem::set_major_version(ArgT0&& arg0, ArgT... args) {
 
 major_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.OperatingSystem.major_version)
}
inline std::string* OperatingSystem::mutable_major_version() {
  std::string* _s = _internal_mutable_major_version();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.OperatingSystem.major_version)
  return _s;
}
inline const std::string& OperatingSystem::_internal_major_version() const {
  return major_version_.Get();
}
inline void OperatingSystem::_internal_set_major_version(const std::string& value) {
  
  major_version_.Set(value, GetArenaForAllocation());
}
inline std::string* OperatingSystem::_internal_mutable_major_version() {
  
  return major_version_.Mutable(GetArenaForAllocation());
}
inline std::string* OperatingSystem::release_major_version() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.OperatingSystem.major_version)
  return major_version_.Release();
}
inline void OperatingSystem::set_allocated_major_version(std::string* major_version) {
  if (major_version != nullptr) {
    
  } else {
    
  }
  major_version_.SetAllocated(major_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (major_version_.IsDefault()) {
    major_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.OperatingSystem.major_version)
}

// string full_version = 3;
inline void OperatingSystem::clear_full_version() {
  full_version_.ClearToEmpty();
}
inline const std::string& OperatingSystem::full_version() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.OperatingSystem.full_version)
  return _internal_full_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperatingSystem::set_full_version(ArgT0&& arg0, ArgT... args) {
 
 full_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.OperatingSystem.full_version)
}
inline std::string* OperatingSystem::mutable_full_version() {
  std::string* _s = _internal_mutable_full_version();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.OperatingSystem.full_version)
  return _s;
}
inline const std::string& OperatingSystem::_internal_full_version() const {
  return full_version_.Get();
}
inline void OperatingSystem::_internal_set_full_version(const std::string& value) {
  
  full_version_.Set(value, GetArenaForAllocation());
}
inline std::string* OperatingSystem::_internal_mutable_full_version() {
  
  return full_version_.Mutable(GetArenaForAllocation());
}
inline std::string* OperatingSystem::release_full_version() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.OperatingSystem.full_version)
  return full_version_.Release();
}
inline void OperatingSystem::set_allocated_full_version(std::string* full_version) {
  if (full_version != nullptr) {
    
  } else {
    
  }
  full_version_.SetAllocated(full_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (full_version_.IsDefault()) {
    full_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.OperatingSystem.full_version)
}

// -------------------------------------------------------------------

// Application

// string name = 1;
inline void Application::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Application::name() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Application.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Application::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Application.name)
}
inline std::string* Application::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Application.name)
  return _s;
}
inline const std::string& Application::_internal_name() const {
  return name_.Get();
}
inline void Application::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Application::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Application::release_name() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Application.name)
  return name_.Release();
}
inline void Application::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Application.name)
}

// string path = 2;
inline void Application::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& Application::path() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Application.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Application::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Application.path)
}
inline std::string* Application::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Application.path)
  return _s;
}
inline const std::string& Application::_internal_path() const {
  return path_.Get();
}
inline void Application::_internal_set_path(const std::string& value) {
  
  path_.Set(value, GetArenaForAllocation());
}
inline std::string* Application::_internal_mutable_path() {
  
  return path_.Mutable(GetArenaForAllocation());
}
inline std::string* Application::release_path() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Application.path)
  return path_.Release();
}
inline void Application::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault()) {
    path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Application.path)
}

// string vendor = 3;
inline void Application::clear_vendor() {
  vendor_.ClearToEmpty();
}
inline const std::string& Application::vendor() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Application.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Application::set_vendor(ArgT0&& arg0, ArgT... args) {
 
 vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Application.vendor)
}
inline std::string* Application::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Application.vendor)
  return _s;
}
inline const std::string& Application::_internal_vendor() const {
  return vendor_.Get();
}
inline void Application::_internal_set_vendor(const std::string& value) {
  
  vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* Application::_internal_mutable_vendor() {
  
  return vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* Application::release_vendor() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Application.vendor)
  return vendor_.Release();
}
inline void Application::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    
  } else {
    
  }
  vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vendor_.IsDefault()) {
    vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Application.vendor)
}

// string url = 4;
inline void Application::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& Application::url() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Application.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Application::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Application.url)
}
inline std::string* Application::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Application.url)
  return _s;
}
inline const std::string& Application::_internal_url() const {
  return url_.Get();
}
inline void Application::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* Application::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* Application::release_url() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Application.url)
  return url_.Release();
}
inline void Application::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Application.url)
}

// string description = 5;
inline void Application::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& Application::description() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Application.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Application::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Application.description)
}
inline std::string* Application::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Application.description)
  return _s;
}
inline const std::string& Application::_internal_description() const {
  return description_.Get();
}
inline void Application::_internal_set_description(const std::string& value) {
  
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* Application::_internal_mutable_description() {
  
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* Application::release_description() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Application.description)
  return description_.Release();
}
inline void Application::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Application.description)
}

// string version = 6;
inline void Application::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& Application::version() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Application.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Application::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Application.version)
}
inline std::string* Application::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Application.version)
  return _s;
}
inline const std::string& Application::_internal_version() const {
  return version_.Get();
}
inline void Application::_internal_set_version(const std::string& value) {
  
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* Application::_internal_mutable_version() {
  
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* Application::release_version() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Application.version)
  return version_.Release();
}
inline void Application::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Application.version)
}

// .google.protobuf.BoolValue signed = 7;
inline bool Application::_internal_has_signed_() const {
  return this != internal_default_instance() && signed__ != nullptr;
}
inline bool Application::has_signed_() const {
  return _internal_has_signed_();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Application::_internal_signed_() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = signed__;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Application::signed_() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Application.signed)
  return _internal_signed_();
}
inline void Application::unsafe_arena_set_allocated_signed_(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* signed_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signed__);
  }
  signed__ = signed_;
  if (signed_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Application.signed)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Application::release_signed_() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = signed__;
  signed__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Application::unsafe_arena_release_signed_() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Application.signed)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = signed__;
  signed__ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Application::_internal_mutable_signed_() {
  
  if (signed__ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    signed__ = p;
  }
  return signed__;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Application::mutable_signed_() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_signed_();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Application.signed)
  return _msg;
}
inline void Application::set_allocated_signed_(::PROTOBUF_NAMESPACE_ID::BoolValue* signed_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(signed__);
  }
  if (signed_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signed_));
    if (message_arena != submessage_arena) {
      signed_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signed_, submessage_arena);
    }
    
  } else {
    
  }
  signed__ = signed_;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Application.signed)
}

// .google.protobuf.BoolValue system_app = 8;
inline bool Application::_internal_has_system_app() const {
  return this != internal_default_instance() && system_app_ != nullptr;
}
inline bool Application::has_system_app() const {
  return _internal_has_system_app();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Application::_internal_system_app() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = system_app_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Application::system_app() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Application.system_app)
  return _internal_system_app();
}
inline void Application::unsafe_arena_set_allocated_system_app(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* system_app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_app_);
  }
  system_app_ = system_app;
  if (system_app) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Application.system_app)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Application::release_system_app() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = system_app_;
  system_app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Application::unsafe_arena_release_system_app() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Application.system_app)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = system_app_;
  system_app_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Application::_internal_mutable_system_app() {
  
  if (system_app_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    system_app_ = p;
  }
  return system_app_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Application::mutable_system_app() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_system_app();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Application.system_app)
  return _msg;
}
inline void Application::set_allocated_system_app(::PROTOBUF_NAMESPACE_ID::BoolValue* system_app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_app_);
  }
  if (system_app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_app));
    if (message_arena != submessage_arena) {
      system_app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_app, submessage_arena);
    }
    
  } else {
    
  }
  system_app_ = system_app;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Application.system_app)
}

// string installation_source = 9;
inline void Application::clear_installation_source() {
  installation_source_.ClearToEmpty();
}
inline const std::string& Application::installation_source() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Application.installation_source)
  return _internal_installation_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Application::set_installation_source(ArgT0&& arg0, ArgT... args) {
 
 installation_source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Application.installation_source)
}
inline std::string* Application::mutable_installation_source() {
  std::string* _s = _internal_mutable_installation_source();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Application.installation_source)
  return _s;
}
inline const std::string& Application::_internal_installation_source() const {
  return installation_source_.Get();
}
inline void Application::_internal_set_installation_source(const std::string& value) {
  
  installation_source_.Set(value, GetArenaForAllocation());
}
inline std::string* Application::_internal_mutable_installation_source() {
  
  return installation_source_.Mutable(GetArenaForAllocation());
}
inline std::string* Application::release_installation_source() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Application.installation_source)
  return installation_source_.Release();
}
inline void Application::set_allocated_installation_source(std::string* installation_source) {
  if (installation_source != nullptr) {
    
  } else {
    
  }
  installation_source_.SetAllocated(installation_source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (installation_source_.IsDefault()) {
    installation_source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Application.installation_source)
}

// -------------------------------------------------------------------

// Profile

// string name = 1;
inline void Profile::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Profile::name() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Profile.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Profile::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Profile.name)
}
inline std::string* Profile::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Profile.name)
  return _s;
}
inline const std::string& Profile::_internal_name() const {
  return name_.Get();
}
inline void Profile::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Profile::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Profile::release_name() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Profile.name)
  return name_.Release();
}
inline void Profile::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Profile.name)
}

// string identifier = 2;
inline void Profile::clear_identifier() {
  identifier_.ClearToEmpty();
}
inline const std::string& Profile::identifier() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Profile.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Profile::set_identifier(ArgT0&& arg0, ArgT... args) {
 
 identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Profile.identifier)
}
inline std::string* Profile::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Profile.identifier)
  return _s;
}
inline const std::string& Profile::_internal_identifier() const {
  return identifier_.Get();
}
inline void Profile::_internal_set_identifier(const std::string& value) {
  
  identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* Profile::_internal_mutable_identifier() {
  
  return identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* Profile::release_identifier() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Profile.identifier)
  return identifier_.Release();
}
inline void Profile::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    
  } else {
    
  }
  identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Profile.identifier)
}

// .google.protobuf.BoolValue removal_allowed = 3;
inline bool Profile::_internal_has_removal_allowed() const {
  return this != internal_default_instance() && removal_allowed_ != nullptr;
}
inline bool Profile::has_removal_allowed() const {
  return _internal_has_removal_allowed();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Profile::_internal_removal_allowed() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = removal_allowed_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Profile::removal_allowed() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Profile.removal_allowed)
  return _internal_removal_allowed();
}
inline void Profile::unsafe_arena_set_allocated_removal_allowed(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* removal_allowed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(removal_allowed_);
  }
  removal_allowed_ = removal_allowed;
  if (removal_allowed) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Profile.removal_allowed)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Profile::release_removal_allowed() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = removal_allowed_;
  removal_allowed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Profile::unsafe_arena_release_removal_allowed() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Profile.removal_allowed)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = removal_allowed_;
  removal_allowed_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Profile::_internal_mutable_removal_allowed() {
  
  if (removal_allowed_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    removal_allowed_ = p;
  }
  return removal_allowed_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Profile::mutable_removal_allowed() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_removal_allowed();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Profile.removal_allowed)
  return _msg;
}
inline void Profile::set_allocated_removal_allowed(::PROTOBUF_NAMESPACE_ID::BoolValue* removal_allowed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(removal_allowed_);
  }
  if (removal_allowed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(removal_allowed));
    if (message_arena != submessage_arena) {
      removal_allowed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, removal_allowed, submessage_arena);
    }
    
  } else {
    
  }
  removal_allowed_ = removal_allowed;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Profile.removal_allowed)
}

// string payload_type = 4;
inline void Profile::clear_payload_type() {
  payload_type_.ClearToEmpty();
}
inline const std::string& Profile::payload_type() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Profile.payload_type)
  return _internal_payload_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Profile::set_payload_type(ArgT0&& arg0, ArgT... args) {
 
 payload_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Profile.payload_type)
}
inline std::string* Profile::mutable_payload_type() {
  std::string* _s = _internal_mutable_payload_type();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Profile.payload_type)
  return _s;
}
inline const std::string& Profile::_internal_payload_type() const {
  return payload_type_.Get();
}
inline void Profile::_internal_set_payload_type(const std::string& value) {
  
  payload_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Profile::_internal_mutable_payload_type() {
  
  return payload_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Profile::release_payload_type() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Profile.payload_type)
  return payload_type_.Release();
}
inline void Profile::set_allocated_payload_type(std::string* payload_type) {
  if (payload_type != nullptr) {
    
  } else {
    
  }
  payload_type_.SetAllocated(payload_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_type_.IsDefault()) {
    payload_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Profile.payload_type)
}

// string payload_identifier = 5;
inline void Profile::clear_payload_identifier() {
  payload_identifier_.ClearToEmpty();
}
inline const std::string& Profile::payload_identifier() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Profile.payload_identifier)
  return _internal_payload_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Profile::set_payload_identifier(ArgT0&& arg0, ArgT... args) {
 
 payload_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Profile.payload_identifier)
}
inline std::string* Profile::mutable_payload_identifier() {
  std::string* _s = _internal_mutable_payload_identifier();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Profile.payload_identifier)
  return _s;
}
inline const std::string& Profile::_internal_payload_identifier() const {
  return payload_identifier_.Get();
}
inline void Profile::_internal_set_payload_identifier(const std::string& value) {
  
  payload_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* Profile::_internal_mutable_payload_identifier() {
  
  return payload_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* Profile::release_payload_identifier() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Profile.payload_identifier)
  return payload_identifier_.Release();
}
inline void Profile::set_allocated_payload_identifier(std::string* payload_identifier) {
  if (payload_identifier != nullptr) {
    
  } else {
    
  }
  payload_identifier_.SetAllocated(payload_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_identifier_.IsDefault()) {
    payload_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Profile.payload_identifier)
}

// -------------------------------------------------------------------

// Date

// int32 year = 1;
inline void Date::clear_year() {
  year_ = 0;
}
inline int32_t Date::_internal_year() const {
  return year_;
}
inline int32_t Date::year() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Date.year)
  return _internal_year();
}
inline void Date::_internal_set_year(int32_t value) {
  
  year_ = value;
}
inline void Date::set_year(int32_t value) {
  _internal_set_year(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.Date.year)
}

// int32 month = 2;
inline void Date::clear_month() {
  month_ = 0;
}
inline int32_t Date::_internal_month() const {
  return month_;
}
inline int32_t Date::month() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Date.month)
  return _internal_month();
}
inline void Date::_internal_set_month(int32_t value) {
  
  month_ = value;
}
inline void Date::set_month(int32_t value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.Date.month)
}

// int32 day = 3;
inline void Date::clear_day() {
  day_ = 0;
}
inline int32_t Date::_internal_day() const {
  return day_;
}
inline int32_t Date::day() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Date.day)
  return _internal_day();
}
inline void Date::_internal_set_day(int32_t value) {
  
  day_ = value;
}
inline void Date::set_day(int32_t value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.Date.day)
}

// -------------------------------------------------------------------

// Certification

// string type = 1;
inline void Certification::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Certification::type() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Certification.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Certification::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Certification.type)
}
inline std::string* Certification::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Certification.type)
  return _s;
}
inline const std::string& Certification::_internal_type() const {
  return type_.Get();
}
inline void Certification::_internal_set_type(const std::string& value) {
  
  type_.Set(value, GetArenaForAllocation());
}
inline std::string* Certification::_internal_mutable_type() {
  
  return type_.Mutable(GetArenaForAllocation());
}
inline std::string* Certification::release_type() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Certification.type)
  return type_.Release();
}
inline void Certification::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Certification.type)
}

// string url = 2;
inline void Certification::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& Certification::url() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Certification.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Certification::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Certification.url)
}
inline std::string* Certification::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Certification.url)
  return _s;
}
inline const std::string& Certification::_internal_url() const {
  return url_.Get();
}
inline void Certification::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* Certification::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* Certification::release_url() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Certification.url)
  return url_.Release();
}
inline void Certification::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Certification.url)
}

// repeated string tags = 10;
inline int Certification::_internal_tags_size() const {
  return tags_.size();
}
inline int Certification::tags_size() const {
  return _internal_tags_size();
}
inline void Certification::clear_tags() {
  tags_.Clear();
}
inline std::string* Certification::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:io.openisms.v1.Certification.tags)
  return _s;
}
inline const std::string& Certification::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& Certification::tags(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Certification.tags)
  return _internal_tags(index);
}
inline std::string* Certification::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Certification.tags)
  return tags_.Mutable(index);
}
inline void Certification::set_tags(int index, const std::string& value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.Certification.tags)
}
inline void Certification::set_tags(int index, std::string&& value) {
  tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.openisms.v1.Certification.tags)
}
inline void Certification::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.openisms.v1.Certification.tags)
}
inline void Certification::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.openisms.v1.Certification.tags)
}
inline std::string* Certification::_internal_add_tags() {
  return tags_.Add();
}
inline void Certification::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.openisms.v1.Certification.tags)
}
inline void Certification::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.openisms.v1.Certification.tags)
}
inline void Certification::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.openisms.v1.Certification.tags)
}
inline void Certification::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.openisms.v1.Certification.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Certification::tags() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Certification.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Certification::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Certification.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// Company

// string name = 1;
inline void Company::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Company::name() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Company.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Company::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Company.name)
}
inline std::string* Company::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Company.name)
  return _s;
}
inline const std::string& Company::_internal_name() const {
  return name_.Get();
}
inline void Company::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Company::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Company::release_name() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Company.name)
  return name_.Release();
}
inline void Company::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Company.name)
}

// string url = 2;
inline void Company::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& Company::url() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Company.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Company::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Company.url)
}
inline std::string* Company::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Company.url)
  return _s;
}
inline const std::string& Company::_internal_url() const {
  return url_.Get();
}
inline void Company::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* Company::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* Company::release_url() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Company.url)
  return url_.Release();
}
inline void Company::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Company.url)
}

// string category = 3;
inline void Company::clear_category() {
  category_.ClearToEmpty();
}
inline const std::string& Company::category() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Company.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Company::set_category(ArgT0&& arg0, ArgT... args) {
 
 category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Company.category)
}
inline std::string* Company::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Company.category)
  return _s;
}
inline const std::string& Company::_internal_category() const {
  return category_.Get();
}
inline void Company::_internal_set_category(const std::string& value) {
  
  category_.Set(value, GetArenaForAllocation());
}
inline std::string* Company::_internal_mutable_category() {
  
  return category_.Mutable(GetArenaForAllocation());
}
inline std::string* Company::release_category() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Company.category)
  return category_.Release();
}
inline void Company::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (category_.IsDefault()) {
    category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Company.category)
}

// .io.openisms.v1.Person contact = 4;
inline bool Company::_internal_has_contact() const {
  return this != internal_default_instance() && contact_ != nullptr;
}
inline bool Company::has_contact() const {
  return _internal_has_contact();
}
inline void Company::clear_contact() {
  if (GetArenaForAllocation() == nullptr && contact_ != nullptr) {
    delete contact_;
  }
  contact_ = nullptr;
}
inline const ::io::openisms::v1::Person& Company::_internal_contact() const {
  const ::io::openisms::v1::Person* p = contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::Person&>(
      ::io::openisms::v1::_Person_default_instance_);
}
inline const ::io::openisms::v1::Person& Company::contact() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Company.contact)
  return _internal_contact();
}
inline void Company::unsafe_arena_set_allocated_contact(
    ::io::openisms::v1::Person* contact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contact_);
  }
  contact_ = contact;
  if (contact) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Company.contact)
}
inline ::io::openisms::v1::Person* Company::release_contact() {
  
  ::io::openisms::v1::Person* temp = contact_;
  contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::Person* Company::unsafe_arena_release_contact() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Company.contact)
  
  ::io::openisms::v1::Person* temp = contact_;
  contact_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::Person* Company::_internal_mutable_contact() {
  
  if (contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::Person>(GetArenaForAllocation());
    contact_ = p;
  }
  return contact_;
}
inline ::io::openisms::v1::Person* Company::mutable_contact() {
  ::io::openisms::v1::Person* _msg = _internal_mutable_contact();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Company.contact)
  return _msg;
}
inline void Company::set_allocated_contact(::io::openisms::v1::Person* contact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete contact_;
  }
  if (contact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contact);
    if (message_arena != submessage_arena) {
      contact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contact, submessage_arena);
    }
    
  } else {
    
  }
  contact_ = contact;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Company.contact)
}

// repeated string address = 5;
inline int Company::_internal_address_size() const {
  return address_.size();
}
inline int Company::address_size() const {
  return _internal_address_size();
}
inline void Company::clear_address() {
  address_.Clear();
}
inline std::string* Company::add_address() {
  std::string* _s = _internal_add_address();
  // @@protoc_insertion_point(field_add_mutable:io.openisms.v1.Company.address)
  return _s;
}
inline const std::string& Company::_internal_address(int index) const {
  return address_.Get(index);
}
inline const std::string& Company::address(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Company.address)
  return _internal_address(index);
}
inline std::string* Company::mutable_address(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Company.address)
  return address_.Mutable(index);
}
inline void Company::set_address(int index, const std::string& value) {
  address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.Company.address)
}
inline void Company::set_address(int index, std::string&& value) {
  address_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.openisms.v1.Company.address)
}
inline void Company::set_address(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.openisms.v1.Company.address)
}
inline void Company::set_address(int index, const char* value, size_t size) {
  address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.openisms.v1.Company.address)
}
inline std::string* Company::_internal_add_address() {
  return address_.Add();
}
inline void Company::add_address(const std::string& value) {
  address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.openisms.v1.Company.address)
}
inline void Company::add_address(std::string&& value) {
  address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.openisms.v1.Company.address)
}
inline void Company::add_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.openisms.v1.Company.address)
}
inline void Company::add_address(const char* value, size_t size) {
  address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.openisms.v1.Company.address)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Company::address() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Company.address)
  return address_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Company::mutable_address() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Company.address)
  return &address_;
}

// -------------------------------------------------------------------

// Pentest

// string id = 1;
inline void Pentest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Pentest::id() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Pentest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pentest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Pentest.id)
}
inline std::string* Pentest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Pentest.id)
  return _s;
}
inline const std::string& Pentest::_internal_id() const {
  return id_.Get();
}
inline void Pentest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Pentest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Pentest::release_id() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Pentest.id)
  return id_.Release();
}
inline void Pentest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Pentest.id)
}

// .io.openisms.v1.Date begin = 2;
inline bool Pentest::_internal_has_begin() const {
  return this != internal_default_instance() && begin_ != nullptr;
}
inline bool Pentest::has_begin() const {
  return _internal_has_begin();
}
inline void Pentest::clear_begin() {
  if (GetArenaForAllocation() == nullptr && begin_ != nullptr) {
    delete begin_;
  }
  begin_ = nullptr;
}
inline const ::io::openisms::v1::Date& Pentest::_internal_begin() const {
  const ::io::openisms::v1::Date* p = begin_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::Date&>(
      ::io::openisms::v1::_Date_default_instance_);
}
inline const ::io::openisms::v1::Date& Pentest::begin() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Pentest.begin)
  return _internal_begin();
}
inline void Pentest::unsafe_arena_set_allocated_begin(
    ::io::openisms::v1::Date* begin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(begin_);
  }
  begin_ = begin;
  if (begin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Pentest.begin)
}
inline ::io::openisms::v1::Date* Pentest::release_begin() {
  
  ::io::openisms::v1::Date* temp = begin_;
  begin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::Date* Pentest::unsafe_arena_release_begin() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Pentest.begin)
  
  ::io::openisms::v1::Date* temp = begin_;
  begin_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::Date* Pentest::_internal_mutable_begin() {
  
  if (begin_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::Date>(GetArenaForAllocation());
    begin_ = p;
  }
  return begin_;
}
inline ::io::openisms::v1::Date* Pentest::mutable_begin() {
  ::io::openisms::v1::Date* _msg = _internal_mutable_begin();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Pentest.begin)
  return _msg;
}
inline void Pentest::set_allocated_begin(::io::openisms::v1::Date* begin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete begin_;
  }
  if (begin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(begin);
    if (message_arena != submessage_arena) {
      begin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, begin, submessage_arena);
    }
    
  } else {
    
  }
  begin_ = begin;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Pentest.begin)
}

// .io.openisms.v1.Date end = 3;
inline bool Pentest::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool Pentest::has_end() const {
  return _internal_has_end();
}
inline void Pentest::clear_end() {
  if (GetArenaForAllocation() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
}
inline const ::io::openisms::v1::Date& Pentest::_internal_end() const {
  const ::io::openisms::v1::Date* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::Date&>(
      ::io::openisms::v1::_Date_default_instance_);
}
inline const ::io::openisms::v1::Date& Pentest::end() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Pentest.end)
  return _internal_end();
}
inline void Pentest::unsafe_arena_set_allocated_end(
    ::io::openisms::v1::Date* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Pentest.end)
}
inline ::io::openisms::v1::Date* Pentest::release_end() {
  
  ::io::openisms::v1::Date* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::Date* Pentest::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Pentest.end)
  
  ::io::openisms::v1::Date* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::Date* Pentest::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::Date>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::io::openisms::v1::Date* Pentest::mutable_end() {
  ::io::openisms::v1::Date* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Pentest.end)
  return _msg;
}
inline void Pentest::set_allocated_end(::io::openisms::v1::Date* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Pentest.end)
}

// .io.openisms.v1.Company company = 4;
inline bool Pentest::_internal_has_company() const {
  return this != internal_default_instance() && company_ != nullptr;
}
inline bool Pentest::has_company() const {
  return _internal_has_company();
}
inline void Pentest::clear_company() {
  if (GetArenaForAllocation() == nullptr && company_ != nullptr) {
    delete company_;
  }
  company_ = nullptr;
}
inline const ::io::openisms::v1::Company& Pentest::_internal_company() const {
  const ::io::openisms::v1::Company* p = company_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::openisms::v1::Company&>(
      ::io::openisms::v1::_Company_default_instance_);
}
inline const ::io::openisms::v1::Company& Pentest::company() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Pentest.company)
  return _internal_company();
}
inline void Pentest::unsafe_arena_set_allocated_company(
    ::io::openisms::v1::Company* company) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(company_);
  }
  company_ = company;
  if (company) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.openisms.v1.Pentest.company)
}
inline ::io::openisms::v1::Company* Pentest::release_company() {
  
  ::io::openisms::v1::Company* temp = company_;
  company_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::openisms::v1::Company* Pentest::unsafe_arena_release_company() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Pentest.company)
  
  ::io::openisms::v1::Company* temp = company_;
  company_ = nullptr;
  return temp;
}
inline ::io::openisms::v1::Company* Pentest::_internal_mutable_company() {
  
  if (company_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::openisms::v1::Company>(GetArenaForAllocation());
    company_ = p;
  }
  return company_;
}
inline ::io::openisms::v1::Company* Pentest::mutable_company() {
  ::io::openisms::v1::Company* _msg = _internal_mutable_company();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Pentest.company)
  return _msg;
}
inline void Pentest::set_allocated_company(::io::openisms::v1::Company* company) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete company_;
  }
  if (company) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(company);
    if (message_arena != submessage_arena) {
      company = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, company, submessage_arena);
    }
    
  } else {
    
  }
  company_ = company;
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Pentest.company)
}

// string focus = 5;
inline void Pentest::clear_focus() {
  focus_.ClearToEmpty();
}
inline const std::string& Pentest::focus() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Pentest.focus)
  return _internal_focus();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pentest::set_focus(ArgT0&& arg0, ArgT... args) {
 
 focus_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Pentest.focus)
}
inline std::string* Pentest::mutable_focus() {
  std::string* _s = _internal_mutable_focus();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Pentest.focus)
  return _s;
}
inline const std::string& Pentest::_internal_focus() const {
  return focus_.Get();
}
inline void Pentest::_internal_set_focus(const std::string& value) {
  
  focus_.Set(value, GetArenaForAllocation());
}
inline std::string* Pentest::_internal_mutable_focus() {
  
  return focus_.Mutable(GetArenaForAllocation());
}
inline std::string* Pentest::release_focus() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Pentest.focus)
  return focus_.Release();
}
inline void Pentest::set_allocated_focus(std::string* focus) {
  if (focus != nullptr) {
    
  } else {
    
  }
  focus_.SetAllocated(focus, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (focus_.IsDefault()) {
    focus_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Pentest.focus)
}

// bool passed = 6;
inline void Pentest::clear_passed() {
  passed_ = false;
}
inline bool Pentest::_internal_passed() const {
  return passed_;
}
inline bool Pentest::passed() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Pentest.passed)
  return _internal_passed();
}
inline void Pentest::_internal_set_passed(bool value) {
  
  passed_ = value;
}
inline void Pentest::set_passed(bool value) {
  _internal_set_passed(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.Pentest.passed)
}

// string result = 7;
inline void Pentest::clear_result() {
  result_.ClearToEmpty();
}
inline const std::string& Pentest::result() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Pentest.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pentest::set_result(ArgT0&& arg0, ArgT... args) {
 
 result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Pentest.result)
}
inline std::string* Pentest::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Pentest.result)
  return _s;
}
inline const std::string& Pentest::_internal_result() const {
  return result_.Get();
}
inline void Pentest::_internal_set_result(const std::string& value) {
  
  result_.Set(value, GetArenaForAllocation());
}
inline std::string* Pentest::_internal_mutable_result() {
  
  return result_.Mutable(GetArenaForAllocation());
}
inline std::string* Pentest::release_result() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Pentest.result)
  return result_.Release();
}
inline void Pentest::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_.IsDefault()) {
    result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Pentest.result)
}

// string url = 8;
inline void Pentest::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& Pentest::url() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Pentest.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pentest::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Pentest.url)
}
inline std::string* Pentest::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Pentest.url)
  return _s;
}
inline const std::string& Pentest::_internal_url() const {
  return url_.Get();
}
inline void Pentest::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* Pentest::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* Pentest::release_url() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Pentest.url)
  return url_.Release();
}
inline void Pentest::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Pentest.url)
}

// repeated .io.openisms.v1.Person contacts = 9;
inline int Pentest::_internal_contacts_size() const {
  return contacts_.size();
}
inline int Pentest::contacts_size() const {
  return _internal_contacts_size();
}
inline void Pentest::clear_contacts() {
  contacts_.Clear();
}
inline ::io::openisms::v1::Person* Pentest::mutable_contacts(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Pentest.contacts)
  return contacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Person >*
Pentest::mutable_contacts() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Pentest.contacts)
  return &contacts_;
}
inline const ::io::openisms::v1::Person& Pentest::_internal_contacts(int index) const {
  return contacts_.Get(index);
}
inline const ::io::openisms::v1::Person& Pentest::contacts(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Pentest.contacts)
  return _internal_contacts(index);
}
inline ::io::openisms::v1::Person* Pentest::_internal_add_contacts() {
  return contacts_.Add();
}
inline ::io::openisms::v1::Person* Pentest::add_contacts() {
  ::io::openisms::v1::Person* _add = _internal_add_contacts();
  // @@protoc_insertion_point(field_add:io.openisms.v1.Pentest.contacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Person >&
Pentest::contacts() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Pentest.contacts)
  return contacts_;
}

// repeated string tags = 10;
inline int Pentest::_internal_tags_size() const {
  return tags_.size();
}
inline int Pentest::tags_size() const {
  return _internal_tags_size();
}
inline void Pentest::clear_tags() {
  tags_.Clear();
}
inline std::string* Pentest::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:io.openisms.v1.Pentest.tags)
  return _s;
}
inline const std::string& Pentest::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& Pentest::tags(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Pentest.tags)
  return _internal_tags(index);
}
inline std::string* Pentest::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Pentest.tags)
  return tags_.Mutable(index);
}
inline void Pentest::set_tags(int index, const std::string& value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.Pentest.tags)
}
inline void Pentest::set_tags(int index, std::string&& value) {
  tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.openisms.v1.Pentest.tags)
}
inline void Pentest::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.openisms.v1.Pentest.tags)
}
inline void Pentest::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.openisms.v1.Pentest.tags)
}
inline std::string* Pentest::_internal_add_tags() {
  return tags_.Add();
}
inline void Pentest::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.openisms.v1.Pentest.tags)
}
inline void Pentest::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.openisms.v1.Pentest.tags)
}
inline void Pentest::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.openisms.v1.Pentest.tags)
}
inline void Pentest::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.openisms.v1.Pentest.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Pentest::tags() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Pentest.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Pentest::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Pentest.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// Repository

// string name = 1;
inline void Repository::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Repository::name() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Repository.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repository::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Repository.name)
}
inline std::string* Repository::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Repository.name)
  return _s;
}
inline const std::string& Repository::_internal_name() const {
  return name_.Get();
}
inline void Repository::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Repository::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Repository::release_name() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Repository.name)
  return name_.Release();
}
inline void Repository::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Repository.name)
}

// string url = 2;
inline void Repository::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& Repository::url() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Repository.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repository::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Repository.url)
}
inline std::string* Repository::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Repository.url)
  return _s;
}
inline const std::string& Repository::_internal_url() const {
  return url_.Get();
}
inline void Repository::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* Repository::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* Repository::release_url() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Repository.url)
  return url_.Release();
}
inline void Repository::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Repository.url)
}

// string description = 3;
inline void Repository::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& Repository::description() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Repository.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repository::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Repository.description)
}
inline std::string* Repository::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Repository.description)
  return _s;
}
inline const std::string& Repository::_internal_description() const {
  return description_.Get();
}
inline void Repository::_internal_set_description(const std::string& value) {
  
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* Repository::_internal_mutable_description() {
  
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* Repository::release_description() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Repository.description)
  return description_.Release();
}
inline void Repository::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Repository.description)
}

// .io.openisms.v1.Visibility visibility = 4;
inline void Repository::clear_visibility() {
  visibility_ = 0;
}
inline ::io::openisms::v1::Visibility Repository::_internal_visibility() const {
  return static_cast< ::io::openisms::v1::Visibility >(visibility_);
}
inline ::io::openisms::v1::Visibility Repository::visibility() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Repository.visibility)
  return _internal_visibility();
}
inline void Repository::_internal_set_visibility(::io::openisms::v1::Visibility value) {
  
  visibility_ = value;
}
inline void Repository::set_visibility(::io::openisms::v1::Visibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.Repository.visibility)
}

// repeated .io.openisms.v1.Person members = 5;
inline int Repository::_internal_members_size() const {
  return members_.size();
}
inline int Repository::members_size() const {
  return _internal_members_size();
}
inline void Repository::clear_members() {
  members_.Clear();
}
inline ::io::openisms::v1::Person* Repository::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Repository.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Person >*
Repository::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Repository.members)
  return &members_;
}
inline const ::io::openisms::v1::Person& Repository::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::io::openisms::v1::Person& Repository::members(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Repository.members)
  return _internal_members(index);
}
inline ::io::openisms::v1::Person* Repository::_internal_add_members() {
  return members_.Add();
}
inline ::io::openisms::v1::Person* Repository::add_members() {
  ::io::openisms::v1::Person* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:io.openisms.v1.Repository.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::openisms::v1::Person >&
Repository::members() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Repository.members)
  return members_;
}

// repeated string security_attributes = 6;
inline int Repository::_internal_security_attributes_size() const {
  return security_attributes_.size();
}
inline int Repository::security_attributes_size() const {
  return _internal_security_attributes_size();
}
inline void Repository::clear_security_attributes() {
  security_attributes_.Clear();
}
inline std::string* Repository::add_security_attributes() {
  std::string* _s = _internal_add_security_attributes();
  // @@protoc_insertion_point(field_add_mutable:io.openisms.v1.Repository.security_attributes)
  return _s;
}
inline const std::string& Repository::_internal_security_attributes(int index) const {
  return security_attributes_.Get(index);
}
inline const std::string& Repository::security_attributes(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Repository.security_attributes)
  return _internal_security_attributes(index);
}
inline std::string* Repository::mutable_security_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Repository.security_attributes)
  return security_attributes_.Mutable(index);
}
inline void Repository::set_security_attributes(int index, const std::string& value) {
  security_attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.Repository.security_attributes)
}
inline void Repository::set_security_attributes(int index, std::string&& value) {
  security_attributes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.openisms.v1.Repository.security_attributes)
}
inline void Repository::set_security_attributes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  security_attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.openisms.v1.Repository.security_attributes)
}
inline void Repository::set_security_attributes(int index, const char* value, size_t size) {
  security_attributes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.openisms.v1.Repository.security_attributes)
}
inline std::string* Repository::_internal_add_security_attributes() {
  return security_attributes_.Add();
}
inline void Repository::add_security_attributes(const std::string& value) {
  security_attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.openisms.v1.Repository.security_attributes)
}
inline void Repository::add_security_attributes(std::string&& value) {
  security_attributes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.openisms.v1.Repository.security_attributes)
}
inline void Repository::add_security_attributes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  security_attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.openisms.v1.Repository.security_attributes)
}
inline void Repository::add_security_attributes(const char* value, size_t size) {
  security_attributes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.openisms.v1.Repository.security_attributes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Repository::security_attributes() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Repository.security_attributes)
  return security_attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Repository::mutable_security_attributes() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Repository.security_attributes)
  return &security_attributes_;
}

// repeated string tags = 10;
inline int Repository::_internal_tags_size() const {
  return tags_.size();
}
inline int Repository::tags_size() const {
  return _internal_tags_size();
}
inline void Repository::clear_tags() {
  tags_.Clear();
}
inline std::string* Repository::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:io.openisms.v1.Repository.tags)
  return _s;
}
inline const std::string& Repository::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& Repository::tags(int index) const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Repository.tags)
  return _internal_tags(index);
}
inline std::string* Repository::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Repository.tags)
  return tags_.Mutable(index);
}
inline void Repository::set_tags(int index, const std::string& value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.Repository.tags)
}
inline void Repository::set_tags(int index, std::string&& value) {
  tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.openisms.v1.Repository.tags)
}
inline void Repository::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.openisms.v1.Repository.tags)
}
inline void Repository::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.openisms.v1.Repository.tags)
}
inline std::string* Repository::_internal_add_tags() {
  return tags_.Add();
}
inline void Repository::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.openisms.v1.Repository.tags)
}
inline void Repository::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.openisms.v1.Repository.tags)
}
inline void Repository::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.openisms.v1.Repository.tags)
}
inline void Repository::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.openisms.v1.Repository.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Repository::tags() const {
  // @@protoc_insertion_point(field_list:io.openisms.v1.Repository.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Repository::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:io.openisms.v1.Repository.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// Statistics

// string identifier = 1;
inline void Statistics::clear_identifier() {
  identifier_.ClearToEmpty();
}
inline const std::string& Statistics::identifier() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Statistics.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Statistics::set_identifier(ArgT0&& arg0, ArgT... args) {
 
 identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Statistics.identifier)
}
inline std::string* Statistics::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Statistics.identifier)
  return _s;
}
inline const std::string& Statistics::_internal_identifier() const {
  return identifier_.Get();
}
inline void Statistics::_internal_set_identifier(const std::string& value) {
  
  identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* Statistics::_internal_mutable_identifier() {
  
  return identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* Statistics::release_identifier() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Statistics.identifier)
  return identifier_.Release();
}
inline void Statistics::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    
  } else {
    
  }
  identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Statistics.identifier)
}

// string name = 2;
inline void Statistics::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Statistics::name() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Statistics.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Statistics::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Statistics.name)
}
inline std::string* Statistics::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Statistics.name)
  return _s;
}
inline const std::string& Statistics::_internal_name() const {
  return name_.Get();
}
inline void Statistics::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Statistics::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Statistics::release_name() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Statistics.name)
  return name_.Release();
}
inline void Statistics::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Statistics.name)
}

// int32 value = 3;
inline void Statistics::clear_value() {
  value_ = 0;
}
inline int32_t Statistics::_internal_value() const {
  return value_;
}
inline int32_t Statistics::value() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Statistics.value)
  return _internal_value();
}
inline void Statistics::_internal_set_value(int32_t value) {
  
  value_ = value;
}
inline void Statistics::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:io.openisms.v1.Statistics.value)
}

// string comment = 4;
inline void Statistics::clear_comment() {
  comment_.ClearToEmpty();
}
inline const std::string& Statistics::comment() const {
  // @@protoc_insertion_point(field_get:io.openisms.v1.Statistics.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Statistics::set_comment(ArgT0&& arg0, ArgT... args) {
 
 comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.openisms.v1.Statistics.comment)
}
inline std::string* Statistics::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:io.openisms.v1.Statistics.comment)
  return _s;
}
inline const std::string& Statistics::_internal_comment() const {
  return comment_.Get();
}
inline void Statistics::_internal_set_comment(const std::string& value) {
  
  comment_.Set(value, GetArenaForAllocation());
}
inline std::string* Statistics::_internal_mutable_comment() {
  
  return comment_.Mutable(GetArenaForAllocation());
}
inline std::string* Statistics::release_comment() {
  // @@protoc_insertion_point(field_release:io.openisms.v1.Statistics.comment)
  return comment_.Release();
}
inline void Statistics::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (comment_.IsDefault()) {
    comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.openisms.v1.Statistics.comment)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace openisms
}  // namespace io

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::io::openisms::v1::SourceSystem_SourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::openisms::v1::SourceSystem_SourceType>() {
  return ::io::openisms::v1::SourceSystem_SourceType_descriptor();
}
template <> struct is_proto_enum< ::io::openisms::v1::OperatingSystem_OperatingSystems> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::openisms::v1::OperatingSystem_OperatingSystems>() {
  return ::io::openisms::v1::OperatingSystem_OperatingSystems_descriptor();
}
template <> struct is_proto_enum< ::io::openisms::v1::Visibility> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::openisms::v1::Visibility>() {
  return ::io::openisms::v1::Visibility_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_io_2fopenisms_2fapi_2eproto
